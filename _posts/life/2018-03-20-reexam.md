---
layout: post
title:  "2018西北工业大学软件工程硕士研究生复试准备（beta版）"
date:  2018-03-20
desc: "本人2018年报考西北工业大学软件工程硕士研究生学位，顺利经过初试考试，现将复试准备的资料整理到这里，希望能帮助到大家。"
keywords: "研究生,硕士,复试,软件工程,西北工业大学"
categories: [Life]
tags: [研究生复试,软件工程]
---
# 顺利经过了研究生的初试，现在即将面临复试，继续加油！！！

## 复试工作流程及工作时间表

### 1. 资格审查

3月21日上午，参加复试的考生携带相关材料到西工大友谊校区毅字楼219室进行复试资格审查，审查合格领取体检表。

  1. **审查材料**：考生本人身份证、毕业证书、学位证书（应届本科毕业生须提供就读学校完整注册后的学生证）原件、准考证、大学阶段学习成绩单、四级或六级成绩单、复试政审表。

  2. **提交材料**：考生本人身份证复印件、毕业证书复印件、学位证书（应届本科毕业生须提供就读学校完整注册后的学生证）复印件、准考证复印件、大学阶段学习成绩单原件、四级或六级成绩单复印件、复试政审表（请按以上顺序整理好）。

### 2. 体检
3月22日上午考生空腹到西工大友谊校区医院参加体检，到校医院体检时化验单（小单子）一定要写上14院或“软微学院”。体检不合格者不能被录取。体检中弄虚作假者一经发现将被取消录取资格。

### 3.复试时间表

![复试时间安排](/assets/images/2018-03/复试时间安排.PNG)

## 复试准备工作
按照复试的流程将所有准备的资料按顺序整理在这里
### 机试
#### 2017年机试原题整理
```java
/**
 * 题目1：编写程序实现折半查找、冒泡排序或者快速排序算法（任意实现其中一个）
 * 
 * 解答：实现快速排序算法
 * @author 王鑫 ；准考证号：
 *
 */
public class Question1 {
	/**
	 * 快速排序函数实现
	 * @param R
	 * @param l
	 * @param r
	 */
	static void QuickSort(int R[],int l,int r) {
		int i,j,temp;
		// 快速排序开始条件
		if(l<r) {
			i = l;
			j = r;
			temp = R[l];
			// 一次快速排序
			while(i<j) {
				while(R[j]>temp&&i<j) {
					j--;
				}
				if(i<j) {
					R[i] = R[j];
					i++;
				}
				while(R[i]<temp&&i<j) {
					i++;
				}
				if(i<j) {
					R[j] = R[i];
					j--;
				}
			}
			
			// 一次排序结束确定temp的位置
			R[i] = temp;
			// 递归执行剩余的部分进行排序
			QuickSort(R,l,i-1);
			QuickSort(R,i+1,r);
		}
	}
	
	/**
	 * 冒泡排序
	 * @param R
	 */
	static void BubbleSort(int R[]) {
		for(int i=R.length-1;i>0;i--) {
			int temp = 0,flag = 0;
			for(int j=1;j<=i;j++) {
				if(R[j-1]>R[j]) {
					temp = R[j-1];
					R[j-1] = R[j];
					R[j] = temp;
					flag = 1;
				}
			}
			// 冒泡排序结束条件
			if(flag == 0) {
				break;
			}
		}
	}
	
	
	/**
	 * 折半查找-递归版
	 * @param R
	 * @param l
	 * @param r
	 * @param s
	 * @return
	 */
	static int BinarySearch(int R[],int start,int end,int key) {
		int middle = (start+end)/2;
		// 查找成功
		if(key == R[middle]) {
			return middle;
		}
		
		// 递归查找
		// 异常处理
		if(start>=end) {
			return -1;
		}else if(key < R[middle]) {
			// 递归需要注意返回值
			return BinarySearch(R,start,middle-1,key);
		}else if(key > R[middle]){
			return BinarySearch(R,middle+1,end,key);
		}
		return -1;
	}
	
	/**
	 * 折半查找，非递归版
	 * @param R
	 * @param start
	 * @param end
	 * @param key
	 * @return
	 */
	static int BinSearch(int R[],int start,int end,int key) {
		while(start<=end) {
			int mid = (start+end)/2;
			if(key == R[mid]) {
				return mid;
			}else if(key<R[mid]) {
				end = mid-1;
			}else if(key>R[mid]) {
				start = mid+1;
			}
		}
		return -1;
	}
	
	/**
	 * 程序入口
	 * @param args
	 */
	public static void main(String[] args) {
		int R[] = {26,12,56,3,8,34,45,123,54,34,78,98,99,333,99};
		//QuickSort(R,0,R.length-1);
		BubbleSort(R);
		// 打印排序结果
		for(int i:R){
			System.out.println(i);
		}
		
		
//		int result = BinarySearch(R,0,R.length-1,54);
//		System.out.println(BinSearch(R,0,R.length-1,123));
	}
}

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 题目要求：
 * 从键盘输入一个字符串（不多于80个字符），
 * 将其中的数字字符按原顺序组成一个新字符串，并输出。
 * 
 * @author 姓名：王鑫    准考证号：
 *
 * 思路：
 * 利用正则表达式将字符串中的数字提取出来
 * 
 * 
 * 考点：正则表达式应用
 * \d:数字字符匹配。等效于 [0-9]。
 * \D:非数字字符匹配。等效于 [^0-9]。
 * [a-z]:字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
 * [^a-z]:反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。
 */
public class Question2 {

	public static void main(String[] args) {
		// 获取键盘输入的字符串
		Scanner scanner = new Scanner(System.in);
		String oldStr = scanner.next();
		scanner.close();
		
		/* 提取数字的正则表达式
		 * 反向匹配字符集，匹配0-9之外的字符 
		 */
		String regEX = "\\D";
		Pattern p =Pattern.compile(regEX);
		Matcher m = p.matcher(oldStr);
		
		/* 输出最终的结果
		 * 对m进行对应的操作返回的是字符串
		 * 将匹配的所有结果用""取代并去空格
		 */
		System.out.println(m.replaceAll("").trim());
	}

}


package code2017;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * 题目要求：
 * 编写程序，从文件中读入两组整数（2*9个数字），分别构造两个3*3维矩阵，最后计算和输出这两个3*3维矩阵的乘积。例如：  
 * 
 * @author 姓名：王鑫    准考证号：
 *
 * 思路：
 * 1.首先先从文件中获取到数据
 * 2.根据从文件中获取到的数据来构建两个二维数组
 * 3.计算两个二位数组的乘积并输出
 * 
 * 
 * 考点：java文件读取数据
 * 使用FileInputStream来读取文件
 * 读取的文件位于项目根路径下
 */
public class Question3 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		// 添加try-catch来捕获异常
		try {
			// 获取文件读取流
			Scanner scanner = new Scanner(new FileInputStream("data.txt"));
			
			// 创建两个3*3的二维数组
			int a[][] = new int[3][3];
			int b[][] = new int[3][3];
			
			// 读取文件中的数字
			while(scanner.hasNextInt()) {
				
				// 构造a矩阵
				for (int i =0;i<3;i++) {
					for (int j=0;j<3;j++) {
						a[i][j] = scanner.nextInt();
					}
				}
				
				// 构造b矩阵
				for (int i =0;i<3;i++) {
					for (int j=0;j<3;j++) {
						b[i][j] = scanner.nextInt();
					}
				}
			}
			
			// 关闭读取流
			scanner.close();
			
			// 计算a矩阵与b矩阵数量积并打印
			for (int i =0;i<3;i++) {
				for (int j=0;j<3;j++) {
					System.out.print(a[i][j]*b[i][j]+"\t");
				}
				System.out.println("");
			}

		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}


package code2017;

import java.util.Scanner;

/**
 * 第四题：编写程序，从键盘输入任一正整数n，
 * 计算并输出数字n的阶乘n!，n!=n*(n-1)!。
 * 例如输入数字为4，则4的阶乘为1×2×3×4=24。
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：
 * 递归实现阶乘
 *
 */
public class Question4 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 获取用户输入的数字
		Scanner scanner = new Scanner(System.in);
		int userInput = scanner.nextInt();
		scanner.close();
		
		// 输出打印结果
		System.out.println(factorial(userInput));
	}
	
	public static int factorial(int a) {
		if (a==1) {
			return 1;
		}
		return a*factorial(a-1);
	}

}


package code2017;
/**
 * 题目：请编写程序实现对二叉树的遍历。
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：
 * 1.首先建立一颗二叉树
 * 2.再对其进行遍历操作：先序遍历，中序遍历，后序遍历
 * 
 * 
 * 考点：建立二叉树，二叉树的操作
 *
 */
public class Question5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 创建一个二叉树
		int a[] = {2,4,12,45,21,6,111};
		BinaryTree tree = new BinaryTree();
		for(int i:a) {
			tree.buildTree(tree.getRoot(), i);
		}
		
		// 前序遍历
		System.out.println("前序遍历");
		tree.preOrder(tree.getRoot());
		// 中序遍历
		System.out.println("中序遍历");
		tree.inOrder(tree.getRoot());
		// 后序遍历
		System.out.println("后序遍历");
		tree.postOrder(tree.getRoot());
	}

}

/**
 * 二叉树类
 * @author 姓名：王鑫    准考证号：
 */
class BinaryTree{
	// 根节点
	private Node root;
	
	public BinaryTree() {
		setRoot(null);
	}
	/**
	 * 内部节点类
     * @author 姓名：王鑫    准考证号：
	 *
	 */
	private class Node{
		// 左节点
		private Node left;
		// 右节点
		private Node right;
		// 节点数据
		private int data;
		
		/**
		 * 构造函数，初始化节点
		 * @param data
		 */
		public Node(int data) {
			this.left = null;
			this.right = null;
			this.data = data;
		}
	}
	
	/**
	 * 迭代构建查找二叉树
	 * @param node
	 * @param data
	 */
	public void buildTree(Node node,int data) {
		// 根节点为空则创建一个新的根节点
		if(null == getRoot()) {
			setRoot(new Node(data));
		}else {
			// 待插入节点值比当前节点值小，往左边插，否则往右边插
			if(data < node.data) {
				// 左节点为空则插到左节点上，否则迭代进行插入
				if(null == node.left) {
					node.left = new Node(data);
				}else {
					buildTree(node.left,data);
				}
			}else {
				// 右节点为空则插到右节点上，否则迭代进行插入
				if(null == node.right) {
					node.right = new Node(data);
				}else {
					buildTree(node.right,data);
				}
			}
		}
	}
	
	/**
	 * 先序遍历：根---》左---》右
	 * @param node
	 */
	public void preOrder(Node node) {
		if(null != node) {
			System.out.println(node.data);
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	/**
	 * 中序遍历：左---》根---》右
	 * @param node
	 */
	public void inOrder(Node node) {
		if(null != node) {
			preOrder(node.left);
			System.out.println(node.data);
			preOrder(node.right);
		}
	}
	
	
	/**
	 * 后序遍历：左---》右---》根
	 * @param node
	 */
	public void postOrder(Node node) {
		if(null != node) {
			preOrder(node.left);
			preOrder(node.right);
			System.out.println(node.data);
		}
	}


	public Node getRoot() {
		return root;
	}


	public void setRoot(Node root) {
		this.root = root;
	}
}


package code2017;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * 题目：读入一个文本文件，并指定某个单词（单词长度不多于5个字符），
 * 例如“we”，统计并输出文件中包含所指定单词的数量（注意不区分大小写）。
 * 
 * @author 姓名：王鑫    准考证号：
 *
 * 思路：依次读取文件中的单词，将其与指定的单词进行比较
 *     相同则次数变量++
 * 
 * 考点：Java中的字符串类型比较
 */
public class Question6 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		try {
			// 保存指定单词个数
			int num = 0;
			// 读取文件
			Scanner scanner = new Scanner(new FileInputStream("data1.txt"));
			// 当文件中的单词与指定的单词一致时则将变量值加一
			while(scanner.hasNext()) {
				if(scanner.next().equals("we")) {
					num++;
				}
			}
			// 读取完成后关闭流
			scanner.close();
			// 打印结果
			System.out.println("we出现次数："+num);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}


package code2017;

import java.util.Scanner;

/**
 * 题目：从键盘上随机输入20个正整数，找出并输出所包含的质数
 * （质数是除了1和它本身之外，不能被其他数整除的正整数，例如2，3，5，11，13等）。
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：1.从键盘循环读取20个整数
 *     2.编写函数计算质数
 *     3.打印出对应的质数
 */
public class Question7 {

	public static void main(String[] args) {
		// 读取键盘输入
		Scanner scanner = new Scanner(System.in);
		// 创建数组存储键盘输入的整数
		int a[] = new int[20];
		System.out.println("请输入20个整数，回车为一个");
		// for循环20次
		for(int i=0;i<20;i++) {
			// 从键盘读取数字
			a[i] = scanner.nextInt();
		}
		// 打印其中的质数
		System.out.println("-----输入中为质数的数如下-----");
		showZhishu(a);
		// 关闭读取流
		scanner.close();
		
	}

	/**
	 * 计算输入的整数对应的质数并打印
	 * @param nextInt
	 */
	private static void showZhishu(int[] a) {
		for(int i:a) {
			// 标识符，确定是否为质数
			int flag = 0;
			for(int j=2;j<i;j++) {
				// 假如能被2到i-1的数整除则不是质数，改变标识符
				if(i%j==0) {
					flag =1;
					break;
				}
			}
			// 只能被1以及自身整除，为质数打印,标识符未改变
			if(flag == 0) {
				System.out.println(i);
			}
		}
		
	}

}


package code2017;

import java.util.Scanner;

/**
 * 题目：请编写程序，将用户输入的一个字符串（不多于100个字符），其中的单词按照逆序，重新输出。
 * 例如输入字符串“this is a dog”，输出为“dog a is this”。
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：
 *    1.使用Scanner获取用户输入的字符串
 *    2.将输入的字符串按照空格切割为一个一个的单词，保存为字符数组
 *    3.将保存单词的数组按照角标从后往前遍历打印
 *    
 * 注意：
 *    Scanner的next方法一次获取输入的一个单词，按空格区分；
 *    而nextLine方法则是一次获取一整行
 */
public class Question8 {

	public static void main(String[] args) {
		// 1.使用Scanner获取用户输入的字符串
		Scanner scanner = new Scanner(System.in);
		String str = scanner.nextLine();
		// 关闭输入流
		scanner.close();
		// 2.将输入的字符串按照空格切割为一个一个的单词
		String[] words = str.split(" ");
		
		// 3.将保存单词的数组按照角标从后往前遍历打印
		for(int i=words.length-1;i>=0;i--) {
			System.out.print(words[i]);
			// 打印字符串中对应的空格
			if(i!=0) {
				System.out.print(" ");
			}
		}
	}

}


package code2017;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 题目：编写一个考试成绩统计程序，将从键盘上输入的学生考试成绩（最多40个），
 * 计算输出学生平均成绩，以及不及格学生数量（成绩<60分）和成绩优秀学生数量（成绩>=90分）。
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：
 *    1.打印成绩统计程序菜单
 *    2.获取用户输入
 *    3.根据用户的输入执行不同的功能
 *    
 *    学生的信息通过java bean来保存，多个学生的信息使用集合来存储
 * 
 * 考点：java集合框架
 * 
 * 学习：
 *    1.集合中按照指定属性排序
 */
public class Question9 {

	public static void main(String[] args) {
		// 1.打印成绩统计程序菜单
		System.out.println("==========考试成绩统计系统 v0.1==========");
		System.out.println("1.输入成绩");
		System.out.println("2.显示学生的成绩信息");
		System.out.println("3.统计学生的信息");
		System.out.println("4.退出");
		
		// 保存所有学生的信息
		List <Student>students = new ArrayList<Student>();
		// 不及格学生数组，按照顺序从高数、英语、c语言进行统计
		int bad[] = new int[3];
		// 优秀学生数组，按照顺序从高数、英语、c语言进行统计
		int good[] = new int[3];
		// 科目数组
		String subject[] = {"高数","英语","c语言"};
		
		// 输入流
		Scanner scanner = new Scanner(System.in);
		
		//2.获取用户输入
		while(true){
			System.out.println("请输入对应数字");
			int userInput = scanner.nextInt();
			
			// 3.根据用户的输入执行不同的功能
			if(1 == userInput) {
				// 输入学生的姓名以及各科的成绩
				System.out.println("请输入学生姓名");
				String name = scanner.next();
				System.out.println("请输入高数成绩");
				double math_score = scanner.nextDouble();
				System.out.println("请输入英语成绩");
				double english_score = scanner.nextDouble();
				System.out.println("请输入c语言成绩");
				double c_score = scanner.nextDouble();
				Student student =new Student(name,math_score,english_score,c_score);
				
				// 判断输入的学生成绩是优秀还是不及格
				if(math_score<60) {
					bad[0]++;
				}
				if(english_score<60) {
					bad[1]++;
				}
				if(c_score<60) {
					bad[2]++;
				}
				if(math_score>=90) {
					good[0]++;
				}
				if(english_score>=90) {
					good[1]++;
				}
				if(c_score>=90) {
					good[2]++;
				}
				students.add(student);
				System.out.println("添加成功");
			}else if(2 == userInput) {
				// 显示学生的各科成绩以及平均成绩
				System.out.println("姓名\t高数成绩\t英语成绩\tc语言成绩\t平均成绩");
				for(Student student1:students) {
					System.out.println(student1.getName()+"\t"+student1.getMath_score()+"\t"+student1.getEnglish_score()+"\t"+student1.getC_score()+"\t"+student1.getBalance_score());
				}
			}else if(3 == userInput) {
				// 统计不及格学生数量（成绩<60分）和成绩优秀学生数量（成绩>=90分）。
				System.out.println("科目\t不及格数\t优秀数\t");
				for(int i = 0;i<3;i++) {
					System.out.println(subject[i]+"\t"+bad[i]+"\t"+good[i]+"\t");
				}
				
			}else if(4 == userInput) {
				scanner.close();
				break;
			}else {
				System.out.println("请输入正确的数字");
			}
		}
	}

}

/**
 * 学生实体类
 * @author 姓名：王鑫    准考证号：
 * 
 * 用来存储学生实体对应的信息，包括高数、英语、c语言成绩
 */
class Student{
	// 学生姓名
	private String name;
	// 高数成绩
	private double math_score;
	// 英语成绩
	private double english_score;
	// c语言成绩
	private double c_score;
	// 平均成绩
	private double balance_score;
	
	
	public double getBalance_score() {
		return balance_score;
	}
	public void setBalance_score(double balance_score) {
		this.balance_score = balance_score;
	}
	/**
	 * 对应属性的set/get方法
	 * @return
	 */
	public double getMath_score() {
		return math_score;
	}
	public void setMath_score(double math_score) {
		this.math_score = math_score;
	}
	public double getEnglish_score() {
		return english_score;
	}
	public void setEnglish_score(double english_score) {
		this.english_score = english_score;
	}
	public double getC_score() {
		return c_score;
	}
	public void setC_score(double c_score) {
		this.c_score = c_score;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	/**
	 * 构造函数
	 * @param math_score
	 * @param english_score
	 * @param c_score
	 */
	public Student(String name, double math_score, double english_score, double c_score) {
		super();
		this.name = name;
		this.math_score = math_score;
		this.english_score = english_score;
		this.c_score = c_score;
		
		// 计算平均成绩
		this.balance_score = (math_score+english_score+c_score)/3;
	}
}
```

#### 2016年机试原题整理
```java
package code2016;
/**
 * 题目1：输出1000以内的所有完数及其因子，所谓完数是指一个整数等于他的因子之和
 * 
 * @author 姓名：王鑫    准考证号：
 * 
 * 思路：
 *    1.使用for循环遍历1000以内所有的数
 *    2.对遍历的没一个数都求出其对应的因子，保存在StringBuffer中
 *    3.将求出的每一个因子相加，判断其值与原数是否相同
 *    4.打印完数以及对应的因子
 *
 */
public class Question1 {

	public static void main(String[] args) {
		// 遍历1000以内的所有数，不包括1，1没有因子
		for(int i=2;i<=1000;i++) {
			// 用来存储完数对应的因子
			StringBuffer sb = new StringBuffer();
			// 计算对应因子之和
			int out=0;
			// 开始计算i对应的因子，并将对应的因子保存起来并相加
			for(int j=1;j<i;j++) {
				if(i%j==0) {
					sb.append(j+" ");
					out+=j;
				}
			}
			// 判断是否是完数，是完数则打印
			if(i == out) {
				System.out.println(i);
				System.out.println(sb.toString().trim());
			}
		}

	}

}


package code2016;
/**
 * 题目2：计算数组元素中值为正数的平均值，0为结束的标识
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 *    遍历数组元素，将其中是正数的元素相加并计数，最后求平均值即可
 *
 */
public class Question2 {

	public static void main(String[] args) {
		// 所需计算的数组
		int num[] = {39,-47,21,2,-8,15,0};
		// 计数
		int index=0;
		// 求和
		int sum=0;
		// 遍历数组
		for(int i:num) {
			// 判断是否为正数
			if(i>0) {
				sum+=i;
				index++;
			}
		}
		// 计算平均值并打印
		System.out.println((double)sum/index);
	}

}


package code2016;
/**
 * 题目3：数组排序
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：冒泡排序
 *
 */
public class Question3 {

	public static void main(String[] args) {
		// 数组
		int a[] = {98,34,24,67,87,99,123,43,76,94,89,53,29,56};
		// 冒泡排序
		BubbleSort(a);
		// 打印排完序后的数组
		for(int i:a) {
			System.out.println(i);
		}

	}

	private static void BubbleSort(int[] a) {
		// 一趟冒泡排序
		for(int i =a.length-1;i>0;i--) {
			// 排序结束标识
			int flag = 0;
			for(int j=1;j<=i;j++) {
				if(a[j-1]>a[j]) {
					int temp = a[j-1];
					a[j-1] = a[j];
					a[j] = temp;
					flag = 1;
				}
			}
			// 判断一趟排序是否有元素变换位置，没有的话排序结束
			if(flag == 0) {
				break;
			}
		}
	}

}


package code2016;
/**
 * 题目4：连接m(1<=m<=10)个字符串为新的字符串并输出
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：使用StringBuffer将所有的字符串保存起来，使用其对应的toString方法输出字符串
 *
 */
public class Question4 {

	public static void main(String[] args) {
		// 创建StringBuffer
		StringBuffer sb = new StringBuffer();
		sb.append("chchchhchhc");
		sb.append("824923jirj");
		sb.append("结婚登记的环境");
		sb.append("和大家互动环节环节的");
		sb.append("的豪华酒店豪华的");
		sb.append("7676897呼呼");
		sb.append("u呃呃呃u金额金额");
		sb.append("烫烫烫烫烫");
		sb.append("基督教世界的健康的");
		System.out.println(sb.toString());

	}

}



package code2016;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 题目5：从键盘输入字符串，要求将字符串中的数字全部过滤掉，并转换为小写
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：使用正则表达式
 *
 */
public class Question5 {

	public static void main(String[] args) {
		// 获取键盘输入
		Scanner scanner = new Scanner(System.in);
		String str = scanner.nextLine();
		scanner.close();
		// 正则表达式匹配串，注意是反斜杠加转义字符
		String reg = "\\d";
		Pattern p = Pattern.compile(reg);
		Matcher m = p.matcher(str);
		System.out.println(m.replaceAll("").toLowerCase());
	}

}



package code2016;

import java.util.Scanner;

/**
 * 题目6：首先在键盘上输入一个整数n，作为数组的大小，接下来依次输入数组对应的元素
 * 将数组中的第一个元素和最后一个元素互换位置，第二个和倒数第二个互换位置，以此类推
 * 最后将原数组以及新的数组打印
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：使用两个指针头指针和尾指针分别指向数组的第一个元素和最后一个元素，交换两个指针所指向的元素，
 * 在头尾指针不相遇的情况下头指针++，尾指针--
 *
 */
public class Question6 {

	public static void main(String[] args) {
		// 获取用户输入的整数n
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int a[] = new int[n];
		
		// 获取数组的元素
		for(int i=0;i<n;i++) {
			a[i] = scanner.nextInt();
		}
		// 关闭输入流
		scanner.close();
		System.out.println("原数组");
		// 打印两个数组
		for(int m:a) {
			System.out.print(m+" ");
		}
		// 保存输入的数组
		int b[] = a;
		
		// 对数组进行元素互换
		int i = 0;
		int j = n-1;
		while(i<j) {
			b[i]^=b[j];
			b[j]^=b[i];
			b[i]^=b[j];
			i++;
			j--;
		}
		System.out.println("\n新数组");
		// 打印两个数组
		for(int m:b) {
			System.out.print(m+" ");
		}
	}

}



package code2016;

import java.util.Scanner;

/**
 * 题目：小王围着操场跑圈，每次跑三圈，请输入行号，没行输入九个整数，表示每次跑步所花费的分钟、秒、毫秒
 * 请计算每次跑步的平均时间
 * 输入示例：
 * 2
 * 1 10 100 1 20 100 1 30 100
 * 2 10 100 1 20 100 1 30 100
 * 输出示例：
 * 1 20 100
 * 1 40 100
 * 
 * @author 姓名：王鑫    考号：
 *
 * 思路：
 * 1分钟等于60秒，1秒等于1000毫秒
 * 根据对应的进制将毫秒加起来，超过1000则进位到秒，将秒加起来超过60则将秒进位到分钟
 * 之后在对对应的分钟，秒，毫秒进行平均计算
 */
public class Question7 {

	public static void main(String[] args) {
		// 接收用户的输入
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		for(int i=0;i<n;i++) {
			int minute = 0;
			int second = 0;
			int millisecond = 0;
			// 获取九组数据
			for(int j=0;j<3;j++) {
				minute += scanner.nextInt();
				second += scanner.nextInt();
				millisecond += scanner.nextInt();
			}
			
			getTimeAverage(minute,second,millisecond);
		}
		// 关闭输入流
		scanner.close();
		
	}

	/**
	 * 计算分钟秒毫秒的平均值
	 * @param minute
	 * @param second
	 * @param millisecond
	 */
	private static void getTimeAverage(int minute, int second, int millisecond) {
		// 首先先将对应的毫秒、秒、分钟相加的和转变为正确格式
		int newsecond = millisecond/1000;
		millisecond = millisecond%1000;
		second = second+newsecond;
		int newminute = second/60;
		second = second%60;
		minute = (minute+newminute)%60;
		
		
		// 接下来将对应的分钟、秒、毫秒进行除3求平均操作
		int aveminute = minute/3;
		second = (minute%3)*60+second;
		int avesecond = second/3;
		millisecond = (second%3)*1000+millisecond;
		int avemillisecond = millisecond/3;
		
		// 输出结果
		System.out.println(aveminute+" "+avesecond+" "+avemillisecond);
		
	}

}
```

#### 2015年机试原题整理
```java
package code2015;

import java.util.Scanner;

/**
 * 题目1：对输入的多行单词字符串用“可变大小”的数组存放，每次都用新开辟的字符串数组替代旧数组
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 *
 */
public class Question1 {

	public static void main(String[] args) {
		// 获取用户输入
		Scanner scanner = new Scanner(System.in);
		scanner.close();
	}

}


package code2015;
/**
 * 题目2：使用递归以及非递归的方式实现折半查找
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 注意：此代码为准确代码，考试时写此代码
 */
public class Question2 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a[] = {1,2,3,4,5,6,7,8,9};
		System.out.println(BinarySearch(a,0,8,1));
	}
	
	/**
	 * 折半查找-递归版
	 * @param a
	 * @param start
	 * @param end
	 * @param target
	 */
	public static int BinarySearchRe(int a[],int start,int end,int target) {
		int mid = start+(end-start)/2;
		// 查找不成功
		if(start>end) {
			return -1;
		}
		// 查找成功的情况
		if(target == a[mid]) {
			return mid;
		}else if(target > a[mid]) {
			// 注意这里的右边界值的处理是使用mid+1
			return BinarySearchRe(a,mid+1,end,target);
		}else if(target < a[mid]){
			return BinarySearchRe(a,start,mid,target);
		}
		return -1;
	}
	
	/**
	 * 折半查找非递归版
	 * @param a
	 * @param start
	 * @param end
	 * @param target
	 * @return
	 */
	public static int BinarySearch(int a[],int start,int end,int target) {
		// 查找条件
		while(start<=end) {
			int mid = start+(end-start)/2;
			if(target == a[mid]) {
				return mid;
			}else if(target<a[mid]) {
				end = mid;
			}else {
				start = mid+1;
			}
		}
		
		return -1;
	}

}



package code2015;
/**
 * 题目：打印数组内元素的全排列
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 *    全排列：从n个不同的元素中任取m个元素按照一定的顺序排列起来。m=n时称其为全排列
 *    首先先从基本的小例子开始：写出1 3 5 9的全排列：
 *    首先保持第一个不变，对3 5 9进行全排列，保持3不变，对5 9进行全排列，保持5不变，对9进行全排列，由于9只有一个，顾它的排列只有一种9，得到1 3 5 9
 *    接下来5不能以5开头了，5 9 互换，得到1 3 9 5
 *    接下来5 9的情况都写完了，不能以3开头了，得到：1 5 3 9，1 5 9 3，1 9 3 5，1 9 5 3
 *    这样，就得到了以1开头的所有排列，接着在以3 5 9开头得到全排列
 *    
 *    递归操作
 *
 */
import java.util.Arrays;  
/** 
 * 获得数组全排列的一个实现算法 
 *  
 * @author 姓名：王鑫    考号：
 * 
 * 思路：递归的执行
 * 
 * 补充：记下这种递归求全排列的操作
 *  
 */  
public class Question3 {
	static int a[] = {1,2,3};
  public static void main(String[] args) {
	  getAllOrder(0,a.length-1);
  }

  /**
   * 获取所有的全排列
   * @param a
   * @param i
   * @param j
   */
  private static void getAllOrder(int i, int j) {
	  // 假如i == j的情况下则直接打印数组
	  if(i == j) {
		  System.out.println(Arrays.toString(a));
	  }else {
		  // i不等于j的情况下使用替换-递归-替换的方法实现全排列打印
		  // 替换的时候换过来再换回来，先换首跟当前变量
		  // 递归开头加一,循环开始是从i开始进行到j
		  for(int k = i;k<=j;k++) {
			  swap(i,k);
			  getAllOrder(i+1,j);
			  swap(k,i);
		  }
	  }
  }

private static void swap(int i, int j) {
	// TODO Auto-generated method stub
	int temp = a[i];
	a[i] = a[j];
	a[j] = temp;
}
}  


package code2015;
/**
 * 题目：找出一串字符中the出现的次数
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：将字符串从空格进行切分，逐个遍历找出the，使用全局变量保存the的个数
 *
 */
public class Question4 {

	public static void main(String[] args) {
		String str = "the world is bad world the people is a good people the love is a perfect love";
		// 按空格将字符串进行切割
		String words[] = str.split(" ");
		// 全局变量，保存the的个数
		int number = 0;
		// 遍历所有的数组进行the的对比
		for(String word:words) {
			if("the".equals(word)) {
				number++;
			}
		}
		
		// 输出结果
		System.out.println(number);

	}

}



package code2015;

import java.util.Arrays;

/**
 * 题目：实现归并排序
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 首先定义两个指针分别指向数组的首尾，并定义中值
 * 递归的执行数组左半部分归并，再递归的执行数组的右半部分归并
 * 最后使用归并方法将左右两半部分组合起来
 * 
 * 注意：递归的归并操作注意角标
 *
 */
public class Question5 {

	public static void main(String[] args) {
		int a[] = {23,19,26,87,4,78,24,45,65,34,29,86,85,96};
		mergeSort(a,0,a.length-1);
		// 打印排序后的结果
		System.out.println(Arrays.toString(a));
	}

	/**
	 * 归并排序
	 * @param a
	 * @param i
	 * @param j
	 */
	private static void mergeSort(int[] a, int start, int end) {
		// 找到中值
		int mid = start+(end-start)/2;
		if(start<end) {
			// 递归执行左半部分
			mergeSort(a,start,mid);
			// 递归执行右半部分
			mergeSort(a,mid+1,end);
			// 左右进行归并
			merge(a,mid,start,end);
		}
	}

	/**
	 * 归并操作
	 * @param a
	 * @param mid
	 * @param start
	 * @param end
	 */
	private static void merge(int[] a, int mid, int start, int end) {
		// 建立新数组用来保存排序后的数组
		int b[] = new int[(end-start)+1];
		// 左指针
		int i = start;
		// 右指针
		int j = mid+1;
		int k = 0;
		
		// 将左右较小的保存到数组里
		while(i<=mid&&j<=end) {
			if(a[i]<a[j]) {
				b[k++]=a[i++];
			}else {
				b[k++]=a[j++];
			}
		}
		
		// 将左边剩余的部分加入到数组中
		while(i<=mid) {
			b[k++]=a[i++];
		}
		
		// 将右边剩余的部分加入到数组中
		while(j<=end) {
			b[k++]=a[j++];
		}
		
		// 将排好序的数组写回到原数组，注意格式，此处是要进行递归调用的，所以写入的角标得加上start
		// 但是b却是从头开始记录的
		for(int m = 0;m<b.length;m++) {
			a[m+start] = b[m];
		}
		
	}

}




package code2015;

import java.util.Scanner;

/**
 * 题目：给出一个整型数组中第k大的值
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：先将数组排好序，在打印出第k-1角标下的数字
 *
 */
public class Question6 {

	public static void main(String[] args) {
		// 获取用户输入的k值
		Scanner scanner = new Scanner(System.in);
		int k = scanner.nextInt();
		// 关闭输入流
		scanner.close();
		
		int a[] = {98,26,56,45,35,65,23,12,64,76,84,34,59};
		// 冒泡排序
		for(int i = a.length-1;i>=0;i--) {
			for(int j = 1;j<=i;j++) {
				if(a[j-1]<a[j]) {
					int temp = a[j-1];
					a[j-1] = a[j];
					a[j] = temp;
				}
			}
		}
		if(k>a.length-1) {
			System.out.print("k值错误");
		}else {
			System.out.print(a[k-1]);
		}
	}

}




package code2015;

import java.util.Scanner;

/**
 * 题目7：n个苹果放在m个盘子里有多少种方法（盘子可以为空）
 * 
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 动态规划：递归降维
 * 通过分类讨论，将规模较大的问题转换成规模较小的相同问题，学会”降维“，将索引值不断降小，就可以递归求解。
 * 设f(m,n)为把m个苹果放到n个盘子中的方法数，m>=0,n>=0.
 * 若m和n中任何一个等于0，那么f(m,n) = 1，注意不是等于0，因为相当于就那么一种结果，就是不往盘子里面放（没有苹果），或者，连盘子都没有。
 * 若n=1,显然对于任意的m>=0?有f(m,1) = 1
 * 若m=1,显然对于任意的n>=0 有f(1,n) = 1
 * 接下来讨论m>1 && n>1的情况：
 * 若 m < n 则 f(m,n) = f(m,m)。即空哪几个盘子都是一样的
 * 若 m>=n 则 大体有两种放法：
 * 第1种情况：至少有一个盘子为空，即什么也不放，这部分的方法数为f(m,n-1);
 * 第2种情况：全部盘子都有苹果，那么先从m个苹果中抽取出n个出来，各个盘子分一个，考虑剩下的m-n个苹果放到n个盘子里的放法，这样就成功把f(m,n)降到了f(m-n,n)。
 * 所以，m>=n时，有f(m,n) = f(m,n-1) + f(m-n,n);
 *
 */
public class Question7 {

	public static void main(String[] args) {
		// 获取输入的m和n
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int m = scanner.nextInt();
		// 关闭输入流
		scanner.close();
		System.out.println(f(n,m));
	}
	
	/**
	 * n个苹果放到m个盘子中去
	 * @param n
	 * @param m
	 * @return
	 */
	public static int f(int n,int m)
	{
		// m为0或者n为0时，只有一种解
		if(m==0||n==0) return 1;
		// m为1或者n为1时
		else if(m==1||n==1) return 1;
		
		// 递归开始
		else{
			if(m>n) return f(n,n);		
			else
			{
				return f(n,m-1)+f(n-m,m);
			}
		}
	}

}




package code2015;

import java.util.Arrays;
import java.util.Scanner;

/**
 * 题目：设计实现顺序栈的基本操作，输入一个字符串，判断小括号是否匹配
 * 
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 自定义栈结构，实现出栈和入栈，获取栈顶元素
 * 并利用自定义的栈结构来判断一个字符串中的小括号是否匹配
 * 利用数组实现
 * 
 * 使用栈来实现，对字符串的单个字符进行判断，如果栈为空则入栈，
 * 如果栈不为空则判断栈顶元素是否与当前元素匹配，匹配则栈顶元素出栈，不匹配则入栈
 * 最后栈为空则小括号匹配，栈不为空则不匹配
 *
 */
public class Question8 {

	public static void main(String[] args) throws Exception {
		ArrayStack<Character> stack =null;
		// 使用Scanner获取用户输入
		Scanner scanner = new Scanner(System.in);
		// 获取用户输入的内容
		String str = scanner.next();
		// 关闭输入流
		scanner.close();
		if(null == str||str.equals("")) {
			System.out.println("输入错误!!!");
		}else {
			// 如果输入的是奇数则证明不匹配
			if(str.length()%2 == 1) {
				System.out.println("不匹配");
			}else {
				// 创建自定义的栈对象
				stack = new ArrayStack<Character>(100);
				// 对字符串中的单个字符进行判断
				for(int i=0;i<str.length();i++) {
					// 当栈为空时，将当前字符压入栈中
					if(stack.isEmpty()) {
						stack.push(str.charAt(i));
					}else {
						// 栈不空时，获取栈顶元素并与当前字符进行匹配，匹配成功则当前执行出栈，匹配不成功则入栈
						if((char)(stack.top())=='('&&str.charAt(i)==')'||(char)(stack.top())=='['&&str.charAt(i)==']') {
							stack.pop();
						}else {
							stack.push(str.charAt(i));
						}
					}
				}
			}
		}
		if(stack.isEmpty()) {
			System.out.println("匹配成功");
		}else {
			System.out.println("匹配失败");
		}
	}

}

/**
 * 自定义栈结构接口，T为泛型，是数据结构类型
 * @author 姓名：王鑫    考号：
 *
 */
interface IStack<T>{
	// 出栈
	public T pop();
	// 入栈
	public void push(T element)throws Exception;
	// 获取栈顶元素
	public T top()throws Exception;
	// 栈判空
	public boolean isEmpty();
	// 栈判溢
	public boolean isFull();
	// 获取当前栈中所存元素的长度
	public int getLength();
	// 清空栈
	public void setEmpty();
	
}

/**
 * 利用数组来实现栈结构
 * @author 姓名：王鑫    考号：
 *
 * @param <T>
 */
class ArrayStack<T> implements IStack<Object>{
	// 栈默认大小
	private final  int DEFAULT_SIZE = 3;
	// 栈最大值
	private int max_size;
	// 栈数组
	private T[] arrayObj;
	// 栈顶指针，初试默认指向-1
	private int top = -1;
	
	/**
	 * 默认构造函数
	 */
	@SuppressWarnings("unchecked")
	public ArrayStack(){
		this.max_size = DEFAULT_SIZE;
		this.arrayObj = (T[])new Object[this.max_size];
		top = -1;
	}
	
	/**
	 * 带初始值的构造函数
	 * @param size
	 */
	@SuppressWarnings("unchecked")
	public ArrayStack(int size) {
		this.max_size = size;
		this.arrayObj = (T[])new Object[this.max_size];
		top = -1;
	}
	/**
	 * 出栈
	 * 首先判断栈是否为空，不为空则将top指针下的元素返回，并且将该位置清空，top指针--
	 */
	@Override
	public Object pop() {
		// TODO Auto-generated method stub
		if(isEmpty()) {
			System.out.println("栈为空！");
			return null;
		}
		T result = (T)arrayObj[top];
		arrayObj[top] = null;
		top--;
		return result;
	}

	/**
	 * 入栈，首先判断入栈的元素是否为空，不为空则入栈成功
	 * 在判断栈是否满，栈满则无法入栈（也可实现为栈满则扩展栈空间），栈不满的情况下将元素存入数组，top++
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void push(Object element) throws Exception{
		// TODO Auto-generated method stub
		if(null == element) {
			throw new Exception("入栈的元素不能为空");
		}
		if(isFull()) {
			System.out.println("栈满了！");
		}else {
			this.arrayObj[++top] = (T)element;
		}
	}

	/**
	 * 获取栈顶元素，首先判断栈是否为空，栈为空的话则抛出异常
	 * 栈不为空的话则返回当前top指针下的内容
	 */
	@Override
	public Object top() throws Exception{
		// TODO Auto-generated method stub
		if(isEmpty()) {
			System.out.println("栈为空！");
			return null;
		}else {
			return this.arrayObj[top];
		}
	}

	/**
	 * 栈判空
	 */
	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		if(top == -1) {
			return true;
		}
		return false;
	}

	/**
	 * 栈判溢
	 */
	@Override
	public boolean isFull() {
		// TODO Auto-generated method stub
		if(top == arrayObj.length-1) {
			return true;
		}
		return false;
	}

	/**
	 * 获取当前栈中所存元素的长度
	 */
	@Override
	public int getLength() {
		// TODO Auto-generated method stub
		return this.top;
	}

	/**
	 * 清空栈
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void setEmpty() {
		// 将数组置空
		Arrays.fill(arrayObj, null);
		
		// 指针归位
		this.top = -1;
		this.max_size = this.DEFAULT_SIZE;
		this.arrayObj = (T[])new Object[max_size];
	}
	
}




package code2015;

import java.util.Scanner;

/**
 * 题目：求最小数
 * 每次给定3个数(均可用int表示)，要求找出3个数里的最小的一个，并输出最小的数。
 * Input three integers and output the minimum 
 *  
 * 输入
 * a b c 三个数用空格隔开
 * Input three integers .
 *  
 * 输出
 * a b c中最小的一个数
 * Output the minimum .
 * 
 * 输入样例
 * 5 3 98
 * 
 * 输出样例
 * 3
 * @author 姓名：王鑫    考号：
 * 
 * 思路：采用打擂台的方式获取三个数中最小的一个，
 * 首先设置一个int型的最大值，接着分别将这个值与输入的三个值进行对比，小的存放在变量中
 * 最后输出这个变量
 *
 */
public class Question9 {

	public static void main(String[] args) {
		// 创建最大的值变量，接下来得用其和输入的其他数进行比较
		int min = Integer.MAX_VALUE;
		// 获取用户的输入
		Scanner scanner = new Scanner(System.in);
		for(int i=0;i<3;i++) {
			int a = scanner.nextInt();
			// 将输入的变量与min中较小的值赋值给min
			min = a<min?a:min;
		}
		// 关闭读取流
		scanner.close();
		System.out.println(min);

	}

}



package code2015;

import java.util.Scanner;

/**
 * 题目：十进制转二进制
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 十进制转二进制是通过除二取余的方式进行的
 * 可以利用StringBuffer将所有余数保存，最后反向打印输出即可
 * 
 * 另一种思路：
 * 可以将模二所得的余数每次乘10加上原先的余数（此方法执行更快）
 *
 */
public class Question10 {

	public static void main(String[] args) {
		// 获取输入的整数
		Scanner scanner = new Scanner(System.in);
		int a = scanner.nextInt();
		// 关闭输入流
		scanner.close();
		// 创建StringBuffer来保存余数
		StringBuffer sb = new StringBuffer();
		while (a>0) {
			sb.append(a%2);
			a /=2;
		}
		// 输出打印结果
		System.out.println(sb.reverse().toString());

	}

}




package code2015;

import java.util.Scanner;

/**
 * 题目：迷宫
 * 描述
有一个迷宫，迷宫里有一个人，迷宫是规格为N*N的方格，人处于某一位置，可以选择向上下左右方向前进，但是要保证面对的不是墙壁，否则无法向前行走。
 
输入
迷宫的规格，用一个正整数N (2<=N<=20)表示,占一行；输入一对数据m，n(第m行，第n列),表示人所在的位置坐标，以空格隔开，占一行；输入要尝试的前进方向，“w”“s”“a”“d”分别代表上、下、左、右，占一行。
 
输出
“Y”
表示可以向该方向前进；最后一行输出回车
“N”
表示无法向该方向前进；最后一行输出回车
 
输入样例
4
0 3
s
 
输出样例
Y
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 判断输入的坐标是否是在边界上，假如不在边界上的话则任意的移动都是可以的
 * 假如是边界上的话：
 * m == 0时w不能走
 * m == N-1时s不能走
 * n == 0时a不能走
 * n == N-1时d不能走
 */
public class Question11 {

	public static void main(String[] args) {
		// 获取对应的输入数据
		Scanner scanner = new Scanner(System.in);
		int N = scanner.nextInt();
		int m = scanner.nextInt();
		int n = scanner.nextInt();
		String operater = scanner.next();
		// 关闭输入流
		scanner.close();

		// 判断用户所处的坐标是否满足要求
		if(m!=0&&m!=(N-1)&&n!=0&&n!=(N-1)) {
			System.out.println("Y");
		}else {
			if(m==0&&operater.equals("w")) {
				System.out.println("N");
			}else if(m==(N-1)&&operater.equals("s")) {
				System.out.println("N");
			}else if(n==0&&operater.equals("a")) {
				System.out.println("N");
			}else if(n==(N-1)&&operater.equals("d")) {
				System.out.println("N");
			}else {
				System.out.println("Y");
			}
		}
	}

}




package code2015;

import java.util.Scanner;

/**
 * 题目：又一个迷宫
 * 描述
有一个迷宫，迷宫里有一个人，迷宫是规格为N*N的方格，房内特定位置上有障碍物，
人处于某一位置，可以选择向上下左右方向前进，但是要保证面对的不是墙壁或是障碍物，否则无法向前行走。
 
输入
迷宫的规格，
一个正整数N (2<=N<=100),占一行，代表矩阵大小；
输入方形矩阵N行N列，由0和1组成，其中0代表空地，1代表障碍物；
输入一对数据m，n(第m行，第n列)，表示人所在的位置坐标(保证人所在的位置为“0”，即空地)，以空格隔开，占一行；
输入一个整数表示要尝试的前进方向，0、1、2、3分别代表左、下、右、上。
 
输出
“Y”
表示可以向该方向前进
“N”
表示无法向该方向前进
输出占一行。
 
输入样例
4
1 0 0 0
1 1 1 0
0 0 1 0
1 0 0 1
0 3
1
 
输出样例
Y


 * 
 * @author 姓名：王鑫     考号：
 * 
 * 思路：
 * 根据输入的n*n的数据创建一个（n+2）*（n+2）的二维数组
 * 并将此数组初始化的时候把0行0列，n+1行n+1列都赋值为1
 * 
 * 再接收输入的n*n的迷宫地图数据，0为可以走，1为不可以走
 * 
 * 最后根据输入的角色坐标上下左右加1来判断对应的位置的元素是否为1来确定是否可以走
 *
 */
public class Question12 {

	public static void main(String[] args) {
		// 获取用户的输入
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int map[][] = new int[n+2][n+2];
		// 获取地图数据，并再对二维数组赋值的时候将边界值赋1
		for(int i=0;i<(n+2);i++) {
			for(int j=0;j<(n+2);j++) {
				// 对边框值赋值1，对非边框值赋值为输入的数据
				if(i==0||i==(n+1)) {
					map[i][j]=1;
				}
				if(j==0||j==(n+1)) {
					map[i][j]=1;
				}
			}
		}
		// 获取用户输入的地图
		for(int i=1;i<(n+1);i++) {
			for(int j=1;j<(n+1);j++) {
				map[i][j]=scanner.nextInt();
			}
		}
		// 获取当前人物所处的坐标
		int a = scanner.nextInt();
		int b = scanner.nextInt();
		// 获取用户想要前进的方向
		int op = scanner.nextInt();
		// 关闭输入流
		scanner.close();
		
		// 根据用户所在的位置即想要前进的方向判断对应角标下的值，0输出Y1输出N
		switch(op) {
		case 0:
			if(map[a][b-1]==0) {
				System.out.println("Y");
			}else {
				System.out.println("N");
			}
			break;
		case 1:
			if(map[a+1][b]==0) {
				System.out.println("Y");
			}else {
				System.out.println("N");
			}
			break;
		case 2:
			if(map[a][b+1]==0) {
				System.out.println("Y");
			}else {
				System.out.println("N");
			}
			break;
		case 3:
			if(map[a-1][b]==0) {
				System.out.println("Y");
			}else {
				System.out.println("N");
			}
			break;
		}
	}

}




package code2015;

import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 题目：字符串替换
 * 描述
输入三个字符串a，b和c，将a中b的第一次出现替换为c。
 
输入
输入三行，每行一个字符串，字符串长度不超过255。
 
输出
如果b有出现在a中，输出替换后的字符串，否则输出原串a。
 
输入样例
abcdefgh
cde
Xiaolan
 
输出样例
abXiaolanfgh
 
提示
所有字符串只包含英文字母。
 * @author 姓名：王鑫    考号：
 * 
 * 思路：
 * 用正则表达式进行匹配
 */
public class Question13 {

	public static void main(String[] args) {
		// 获取输入的三个字符串
		Scanner scanner = new Scanner(System.in);
		String a = scanner.next();
		String b = scanner.next();
		String c = scanner.next();
		// 关闭输入流
		scanner.close();
		
		// 正则匹配串
		Pattern p = Pattern.compile(b);
		Matcher m = p.matcher(a);
		
		// 将满足的字符串替换为c
		System.out.println(m.replaceAll(c));
	}

}




package code2015;

import java.util.Arrays;
import java.util.Scanner;

/*
1165.六数码问题
时限：1000ms 内存限制：10000K  总时限：3000ms
描述
现有一两行三列的表格如下：

A B C
D E F

把1、2、3、4、5、6六个数字分别填入A、B、C、D、E、F格子中，每个格子一个数字且各不相同。每种不同的填法称为一种布局。如下：

1 3 5
2 4 6
布局1

2 5 6
4 3 1
布局2

定义α变换如下：把A格中的数字放入B格，把B格中的数字放入E格，把E格中的数字放入D格，把D格中的数字放入A格。
定义β变换如下：把B格中的数字放入C格，把C格中的数字放入F格，把F格中的数字放入E格，把E格中的数字放入B格。

问：对于给定的布局，可否通过有限次的α变换和β变换变成下面的目标布局：

1 2 3
4 5 6
 
输入
本题有多个测例，第一行为输入测例的个数n，下面是n行测例，每个测例的输入是1到6这六个数字的一个排列，空格隔开，表示初始布局ABCDEF格中依次填入的数字。
 
输出
每个输出占一行。输出转换到目标格局需要变换的最少次数。（若不能转换则输出-1）
 
输入样例
2
2 5 3 1 4 6
2 3 6 1 5 4
 
输出样例
1
2

 
提示
注意不能转换到目标格局的情况应输出-1；
输出格式为：printf(“%d\n”,min);

思路：

目标结果是123456，当不满足目标结果的时候：
假如14两个数连在一起而36两个数不连在一起则证明需要进行a变换
假如36两个数连在一起而14两个数不连在一起则证明需要进行b变换
假如14，36两个数都不连在一起则证明无法进行转换

递归进行转换函数
 */
public class Question14 {
	public static void main(String[] args) {
		// 获取输入数据
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int a[][] = new int[n][6];
		for(int i=0;i<n;i++) {
			for(int j=0;j<6;j++) {
				a[i][j] = scanner.nextInt();
			}
		}
		// 关闭输入流
		scanner.close();
		int result[] = new int[n];
		// 进行六位码运算，变换操作默认为空
		for(int i=0;i<n;i++) {
			result[i] = SixCodeResult(a[i]," ");
		}
		// 输出结果
		for(int i=0;i<n;i++) {
			System.out.println(result[i]);
		}

	}

	/**
	 * 进行六位码运算
	 * @param is
	 * @param op
	 * @return
	 */
	private static int SixCodeResult(int[] is,String op) {
		int sum = 0;
		// 对数组进行相应的op操作
		if(op.equals("a")) {
			a(is);
			sum++;
		}
		if(op.equals("b")) {
			b(is);
			sum++;
		}
		// 对传入数组的情况进行判断
		int right[] = {1,2,3,4,5,6};
		if(Arrays.equals(is,right)){
			return sum;
		}else {
			// 判断是14相邻还是36相邻,14相邻递归执行a变换
			// 36相邻递归执行b变换
			// 都不相邻则返回-1
			return -1;
		}
	}

	/**
	 * b操作
	 * @param is
	 */
	private static void b(int[] is) {
		// TODO Auto-generated method stub
		
	}

	/**
	 * a操作
	 * @param is
	 */
	private static void a(int[] is) {
		// TODO Auto-generated method stub
		
	}
}




package code2015;
/*
1422.输出命题公式的真值表
时限：1000ms 内存限制：10000K  总时限：3000ms
描述
先输入一个正整数n（n小于等于10），表示共有n个命题变元，
再输入一个类似于逆波兰表达式的字符串表示一个命题公式，
约定在该字符串中用一位的十进制数表示一个命题变元，用a、o、n、i、e分别表示且、或、非、蕴含、等值，
用类似于逆波兰表达式形式的字符串表示的命题公式的真值表波兰表达式
（即二元运算，两个操作数在前，运算符在后；一元运算，一个操作数在前，运算符在后）。
 
输入
先输入一个小于等于10的正整数n，再输入一个字符串。
 
输出
输出该字符串表示的命题公式的真值表。
提示：
如果用P、Q、R分别表示这三个命题变元的话，
输入数据01a2i表示的命题公式是：((P∧Q)→R)
输入数据012ia表示的命题公式是：(P∧(Q→R))
输入数据0n表示的命题公式是：┐P
 
输入样例
3
01a2i
 
输出样例
0 0 0 1
0 0 1 1
0 1 0 1
0 1 1 1
1 0 0 1
1 0 1 1
1 1 0 0
1 1 1 1
 
*/
public class Question15 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}




package code2015;

import java.util.Scanner;

/*
1221.计算单词的个数
时限：1000ms 内存限制：10000K  总时限：3000ms
描述
给以行句子，写一个程序判断它有几个单词。
 
输入
输入占一行，行尾有空格，并且只含有大写字母和小写字母和空格。
 
输出
单词的个数。
例如：
printf("%d\n"),num;
 
输入样例
General game players are systems able to 
 
输出样例
7
 
提示
 
来源
 */
public class Question16 {

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		String str = scanner.nextLine();
		// 关闭输入流
		scanner.close();
		String sum[] = str.split(" ");
		// 打印数组的长度即为单词个数
		System.out.println(sum.length);

	}

}




package code2015;

import java.util.Scanner;

/**
 * 1441.连阴雨
时限：1000ms 内存限制：10000K  总时限：3000ms
描述
因为连续的降雨，我们学校操场上出现了许多水坑，现在需要统计一共有多少个水坑。
题目输入为一个N譓 (1 <= N <= 100; 1 <= M <= 100)的图，('W') 代表积水，('.')代表干燥。
一处积水我们认为和它周围的八个方向相邻，相邻的积水构成一个水坑。
需要输出一个数字，表示一共有多少个互不相邻的水坑。
 
输入
第一行：两个正整数n和m。
第二行到第n+1行：输入操场信息，每一点的状态只可能是'W' 或者'.'。

输出
输出一个正整数，表示不相邻的水坑的数目。
 
输入样例
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
 
3 4
.WWW
....
..W.
输出样例
3
 * @author wang
 *
 */
public class Question17 {

	// 全局变量，保存输入的数据
	static int  m,n;
	static char a[][];
	static int vis[][];
	// 水坑计数
	static int number = 0;
	
	public static void main(String[] args) {
		// 获取用户的输入
		Scanner scanner = new Scanner(System.in);
		n = scanner.nextInt();
		m = scanner.nextInt();
		// 输入的信息数组
		a = new char[n][m];
		// 访问信息数组，vis[i][j] = 0表示未被访问
		vis = new int[n][m];
		
		// 接收输入的数组，并将访问数组初始化
		for(int i= 0;i<n;i++) {
			String str = scanner.next();
			for(int j=0;j<m;j++) {
				a[i][j] = str.charAt(j);
				vis[i][j] = 0;
			}
		}
		// 关闭输入流
		scanner.close();
		
		// 对水坑的数据进行判断
		for(int i= 0;i<n;i++) {
			for(int j=0;j<m;j++) {
				// 假如当前ij对应的vis数组值为0表示未被访问且a数组的值为W则进行一次深度优先遍历，计数值加一
				if(vis[i][j]==0&&a[i][j]=='W') {
					dnf(i,j);
					number++;
				}
			}
		}
		
		// 输出结果
		System.out.println(number);

	}

	/**
	 * 深度优先遍历
	 * @param a
	 * @param vis
	 * @param i
	 * @param j
	 */
	private static void dnf(int i, int j) {
		// TODO Auto-generated method stub
		vis[i][j]=1;
		// 对周围八个点进行判断
		for(int x=-1;x<=1;x++) {
			for(int y=-1;y<=1;y++) {
				// 首先该点不超过数组的最小最大边界，并且该数组未被访问过，且该位置的a数组为w
				if(0<=(i+x)&&(i+x)<n&&0<=(j+y)&&(j+y)<m&&vis[i+x][j+y]==0&&a[i+x][j+y]=='W') {
					dnf(i+x,j+y);
				}
			}
		}
	}

}

```