---
layout: post
title:  "2018年西北工业大学软件工程研究生入学复试准备"
date:  2017-07-28
desc: "一年一度的考研大战终于到了最后一个关口，面临这次异常惨烈的复试之战，应该调整好心态，全力迎战。接下来就是展现你自己真实实力的时候了，加油。"
keywords: "2018,西北工业大学,软件工程,研究生,复试,硕士,全日制"
categories: [Life]
tags: [考研复试]
---
# 顺利经过了研究生的初试，现在即将面临复试，继续加油！！！

## 复试工作流程及工作时间表

### 1. 资格审查(以完成)

3月21日上午，参加复试的考生携带相关材料到西工大友谊校区毅字楼219室进行复试资格审查，审查合格领取体检表。

  1. **审查材料**：考生本人身份证、毕业证书、学位证书（应届本科毕业生须提供就读学校完整注册后的学生证）原件、准考证、大学阶段学习成绩单、四级或六级成绩单、复试政审表。

  2. **提交材料**：考生本人身份证复印件、毕业证书复印件、学位证书（应届本科毕业生须提供就读学校完整注册后的学生证）复印件、准考证复印件、大学阶段学习成绩单原件、四级或六级成绩单复印件、复试政审表（请按以上顺序整理好）。

### 2. 体检(以完成)
3月22日上午考生空腹到西工大友谊校区医院参加体检，到校医院体检时化验单（小单子）一定要写上14院或“软微学院”。体检不合格者不能被录取。体检中弄虚作假者一经发现将被取消录取资格。


### 3.复试时间表
![复试安排](/assets/images/2018-03/复试时间安排.PNG)


## 复试准备工作
按照复试的流程将所有准备的资料按顺序整理在这里
### 机试

机试知识点整理：
#### 2015年机试题目重点整理
1. 获取输入的n行不定长数据的方法：
首先先使用nextInt方法获取输入的n值，再使用nextLine方法跳过当前行，再循环遍历n次接收输入的nextLine，接收类型为String类型，需要对其进行相关的操作，完善数据输入。
2. 折半查找（必考题）：主要注意中值的获取以及右半部分查找时得中值加一 递归版：
```java
// 递归时必须指定递归结束条件
public static int BinarySearchRe(int a[],int start,int end,int target) {
  // 获取中值方法：头+（尾-头）/2
	int mid = start+(end-start)/2;
	// 查找不成功
	if(start>end) {
		return -1;
	}
	// 查找成功的情况
	if(target == a[mid]) {
		return mid;
	}else if(target > a[mid]) {
		// 注意这里的右边界值的处理是使用mid+1
    // 因为int型都是向下取整的
		return BinarySearchRe(a,mid+1,end，target);
	}else if(target < a[mid]){
		return BinarySearchRe(a,start,mid,target);
    	}
	return -1;
}
```
非递归版（循环版）：
```java
public static int BinarySearch(int a[],int start,int end,int target) {
	// 查找条件头小于等于尾
	while(start<=end) {
		int mid = start+(end-start)/2;
		if(target == a[mid]) {
			return mid;
		}else if(target<a[mid]) {
			end = mid;
		}else {
      // 右中值得加一
			start = mid+1;
		}
	}	
	return -1;
}
```
3. 数组元素全排列（递归求解）：方法中传入数组的头i和尾j，当i == j的时候就打印数组，否则就执行循环从i到j用k取值，执行替换-递归-替换；替换是换i和k(作为新的头进行排列)，递归i+1，j（执行下一组打印），再替换k和i（再换回来）；替换操作是普通的交换两个元素的算法。
注：数组打印可以直接使用Arrays.toString(数组)
```java
public class Question3 {
  // a为全局变量，要对a的值进行获取
	static int a[] = {1,2,3};
  public static void main(String[] args) {
	  getAllOrder(0,a.length-1);
  }

  /**
   * 获取所有的全排列
   * @param a
   * @param i
   * @param j
   */
  private static void getAllOrder(int i, int j) {
	  // 假如i == j的情况下则直接打印数组
	  if(i == j) {
		  System.out.println(Arrays.toString(a));
	  }else {
		  // i不等于j的情况下使用替换-递归-替换的方法实现全排列打印
		  // 替换的时候换过来再换回来，先换首跟当前变量
		  // 递归开头加一,循环开始是从i开始进行到j
		  for(int k = i;k<=j;k++) {
			  swap(i,k);
			  getAllOrder(i+1,j);
			  swap(k,i);
		  }
	  }
  }

private static void swap(int i, int j) {
	// TODO Auto-generated method stub
	int temp = a[i];
	a[i] = a[j];
	a[j] = temp;
}
}  
```
4. 寻找字符串中指定字符出现的次数：直接使用nextLine方法接收输入的一行字符串，使用字符串的split方法传入空格作为切分条件将字符串切成一个个的单词，返回值是个String类型的数组，遍历数组查找对应的字符是否出现即可。
5. 归并排序(递归实现)：首先使用start和end两个指针指向数组的头和尾，并定义中值。接下来递归的对数组的左半部分进行归并，对数组的右半部分进行归并。最后使用归并方法将左右两部分组合起来。
```java
public class Question5 {

	public static void main(String[] args) {
		int a[] = {23,19,26,87,4,78,24,45,65,34,29,86,85,96};
		mergeSort(a,0,a.length-1);
		// 打印排序后的结果
		System.out.println(Arrays.toString(a));
	}

	/**
	 * 归并排序
	 * @param a
	 * @param i
	 * @param j
	 */
	private static void mergeSort(int[] a, int start, int end) {
		// 找到中值(头+（尾-头）/2)
		int mid = start+(end-start)/2;
    // 归并排序起始条件
		if(start<end) {
			// 递归执行左半部分
			mergeSort(a,start,mid);
			// 递归执行右半部分（注意mid+1）
			mergeSort(a,mid+1,end);
			// 左右进行归并
			merge(a,mid,start,end);
		}
	}

	/**
	 * 归并操作，左右指针同时走
	 * @param a
	 * @param mid
	 * @param start
	 * @param end
	 */
	private static void merge(int[] a, int mid, int start, int end) {
		// 建立新数组用来保存排序后的数组
		int b[] = new int[(end-start)+1];
		// 左指针
		int i = start;
		// 右指针
		int j = mid+1;
    // 新数组保存指针
		int k = 0;
		
		// 将左右较小的保存到数组里
		while(i<=mid&&j<=end) {
			if(a[i]<a[j]) {
				b[k++]=a[i++];
			}else {
				b[k++]=a[j++];
			}
		}
		
		// 将左边剩余的部分加入到数组中
		while(i<=mid) {
			b[k++]=a[i++];
		}
		
		// 将右边剩余的部分加入到数组中
		while(j<=end) {
			b[k++]=a[j++];
		}
		
		// 将排好序的数组写回到原数组，注意格式，此处是要进行递归调用的，所以写入的角标得加上start
		// 但是b却是从头开始记录的
		for(int m = 0;m<b.length;m++) {
			a[m+start] = b[m];
		}
		
	}
}
```
6. 排序类应用：这类题一般得将数组进行排序操作，建议使用冒泡排序，简单方便
```java
for(int i = a.length-1;i>=0;i--) {
	for(int j = 1;j<=i;j++) {
	  if(a[j-1]<a[j]) {
			int temp = a[j-1];
			a[j-1] = a[j];
			a[j] = temp;
		}
	}
}
```
7. 动态规划问题：n个苹果放到m个篮子里有多少种方法
 * 思路：
 * 动态规划：递归降维
 * 通过分类讨论，将规模较大的问题转换成规模较小的相同问题，学会”降维“，将索引值不断降小，就可以递归求解。
 * 设f(m,n)为把m个苹果放到n个盘子中的方法数，m>=0,n>=0.
 * 若m和n中任何一个等于0，那么f(m,n) = 1，注意不是等于0，因为相当于就那么一种结果，就是不往盘子里面放（没有苹果），或者，连盘子都没有。
 * 若n=1,显然对于任意的m>=0?有f(m,1) = 1
 * 若m=1,显然对于任意的n>=0 有f(1,n) = 1
 * 接下来讨论m>1 && n>1的情况：
 * 若 m < n 则 f(m,n) = f(m,m)。即空哪几个盘子都是一样的
 * 若 m>=n 则 大体有两种放法：
 * 第1种情况：至少有一个盘子为空，即什么也不放，这部分的方法数为f(m,n-1);
 * 第2种情况：全部盘子都有苹果，那么先从m个苹果中抽取出n个出来，各个盘子分一个，考虑剩下的m-n个苹果放到n个盘子里的放法，这样就成功把f(m,n)降到了f(m-n,n)。
 * 所以，m>=n时，有f(m,n) = f(m,n-1) + f(m-n,n);
 ```java
 public static int f(int n,int m)
	{
		// m为0或者n为0时，只有一种解
		if(m==0||n==0) return 1;
		// m为1或者n为1时
		else if(m==1||n==1) return 1;
		
		// 递归开始
		else{
			if(m>n) return f(n,n);		
			else
			{
				// 两种情况是加到一起算的（算可能性）
				return f(n,m-1)+f(n-m,m);
			}
		}
	}
 ```
 8. 设计实现顺序栈的基本操作，输入一个字符串，判断小括号是否匹配
 * 思路：
 * 自定义栈结构，实现出栈和入栈，获取栈顶元素
 * 并利用自定义的栈结构来判断一个字符串中的小括号是否匹配
 * 利用数组实现
 * 
 * 使用栈来实现，对字符串的单个字符进行判断，如果栈为空则入栈，
 * 如果栈不为空则判断栈顶元素是否与当前元素匹配，匹配则栈顶元素出栈，不匹配则入栈
 * 最后栈为空则小括号匹配，栈不为空则不匹配
 对于字符串中的单个字符进行操作可以使用for循环遍历字符串长度，然后使用charat来获取指定位置的字符。
 ```java
 public class Question8 {

	public static void main(String[] args) throws Exception {
		ArrayStack<Character> stack =null;
		// 使用Scanner获取用户输入
		Scanner scanner = new Scanner(System.in);
		// 获取用户输入的内容
		String str = scanner.next();
		// 关闭输入流
		scanner.close();
		if(null == str||str.equals("")) {
			System.out.println("输入错误!!!");
		}else {
			// 如果输入的是奇数则证明不匹配
			if(str.length()%2 == 1) {
				System.out.println("不匹配");
			}else {
				// 创建自定义的栈对象
				stack = new ArrayStack<Character>(100);
				// 对字符串中的单个字符进行判断
				for(int i=0;i<str.length();i++) {
					// 当栈为空时，将当前字符压入栈中
					if(stack.isEmpty()) {
						stack.push(str.charAt(i));
					}else {
						// 栈不空时，获取栈顶元素并与当前字符进行匹配，匹配成功则当前执行出栈，匹配不成功则入栈
						if((char)(stack.top())=='('&&str.charAt(i)==')'||(char)(stack.top())=='['&&str.charAt(i)==']') {
							stack.pop();
						}else {
							stack.push(str.charAt(i));
						}
					}
				}
			}
		}
		if(stack.isEmpty()) {
			System.out.println("匹配成功");
		}else {
			System.out.println("匹配失败");
		}
	}

}

/**
 * 自定义栈结构接口，T为泛型，是数据结构类型
 * @author 姓名：王鑫    考号：
 *
 */
interface IStack<T>{
	// 出栈
	public T pop();
	// 入栈
	public void push(T element)throws Exception;
	// 获取栈顶元素
	public T top()throws Exception;
	// 栈判空
	public boolean isEmpty();
	// 栈判溢
	public boolean isFull();
	// 获取当前栈中所存元素的长度
	public int getLength();
	// 清空栈
	public void setEmpty();
	
}

/**
 * 利用数组来实现栈结构
 * @author 姓名：王鑫    考号：
 *
 * @param <T>
 */
class ArrayStack<T> implements IStack<Object>{
	// 栈默认大小
	private final  int DEFAULT_SIZE = 3;
	// 栈最大值
	private int max_size;
	// 栈数组
	private T[] arrayObj;
	// 栈顶指针，初试默认指向-1
	private int top = -1;
	
	/**
	 * 默认构造函数
	 */
	@SuppressWarnings("unchecked")
	public ArrayStack(){
		this.max_size = DEFAULT_SIZE;
		this.arrayObj = (T[])new Object[this.max_size];
		top = -1;
	}
	
	/**
	 * 带初始值的构造函数
	 * @param size
	 */
	@SuppressWarnings("unchecked")
	public ArrayStack(int size) {
		this.max_size = size;
		this.arrayObj = (T[])new Object[this.max_size];
		top = -1;
	}
	/**
	 * 出栈
	 * 首先判断栈是否为空，不为空则将top指针下的元素返回，并且将该位置清空，top指针--
	 */
	@Override
	public Object pop() {
		// TODO Auto-generated method stub
		if(isEmpty()) {
			System.out.println("栈为空！");
			return null;
		}
		T result = (T)arrayObj[top];
		arrayObj[top] = null;
		top--;
		return result;
	}

	/**
	 * 入栈，首先判断入栈的元素是否为空，不为空则入栈成功
	 * 在判断栈是否满，栈满则无法入栈（也可实现为栈满则扩展栈空间），栈不满的情况下将元素存入数组，top++
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void push(Object element) throws Exception{
		// TODO Auto-generated method stub
		if(null == element) {
			throw new Exception("入栈的元素不能为空");
		}
		if(isFull()) {
			System.out.println("栈满了！");
		}else {
			this.arrayObj[++top] = (T)element;
		}
	}

	/**
	 * 获取栈顶元素，首先判断栈是否为空，栈为空的话则抛出异常
	 * 栈不为空的话则返回当前top指针下的内容
	 */
	@Override
	public Object top() throws Exception{
		// TODO Auto-generated method stub
		if(isEmpty()) {
			System.out.println("栈为空！");
			return null;
		}else {
			return this.arrayObj[top];
		}
	}

	/**
	 * 栈判空
	 */
	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		if(top == -1) {
			return true;
		}
		return false;
	}

	/**
	 * 栈判溢
	 */
	@Override
	public boolean isFull() {
		// TODO Auto-generated method stub
		if(top == arrayObj.length-1) {
			return true;
		}
		return false;
	}

	/**
	 * 获取当前栈中所存元素的长度
	 */
	@Override
	public int getLength() {
		// TODO Auto-generated method stub
		return this.top;
	}

	/**
	 * 清空栈
	 */
	@SuppressWarnings("unchecked")
	@Override
	public void setEmpty() {
		// 将数组置空
		Arrays.fill(arrayObj, null);
		
		// 指针归位
		this.top = -1;
		this.max_size = this.DEFAULT_SIZE;
		this.arrayObj = (T[])new Object[max_size];
	}
	
}
 ```
 9. Integer有默认的int型最大值和最小值，Integer.MAX_VALUE为int型最大值，Integer.MIN_VALUE为int型最小值。
 10. 十进制转二进制：原数%2结果*10再加上原数/2的值再继续%2，循环到原数为0，可以将模二所得的余数每次乘10加上原先的余数（此方法执行更快）
 11. 迷宫问题可以在迷宫的基础上在加上一圈的1表示不能前进，这样能保证数组可以在对应的操作下不越界。
 12. 正则表达式匹配问题：首先记住正则表达式的代码
 ```java
 // 使用正则表达式创建模型，注意Pattern是静态类，不能使用new方法进行创建
 Pattern p = Pattern.compile("正则表达式");
 // 由模型生成匹配对象，传入要被处理的字符串
 Matcher m = p.matcher("要被处理的字符串");
 // 执行匹配对象的相关操作，最常用的是替换所有,trim()为去空格
 System.out.println(m.replaceAll("用来替换符合正则的字符串").trim())
 ```
 13. 常用正则表达式列举：
 * \d:数字字符匹配。等效于 [0-9]。
 * \D:非数字字符匹配。等效于 [^0-9]。
 * [a-z]:字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
 * [^a-z]:反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。
 14. 二维数组应用深度优先遍历求解，
 ```java
 private static void dnf(int i, int j) {
	// 深度优先遍历得有一个访问数组记录数组的访问状态
	vis[i][j]=1;
	// 对周围八个点进行判断
	for(int x=-1;x<=1;x++) {
		for(int y=-1;y<=1;y++) {
			// 首先该点不超过数组的最小最大边界，并且该数组未被访问过，且该位置的a数组为w
			if(0<=(i+x)&&(i+x)<n&&0<=(j+y)&&(j+y)<m&&vis[i+x][j+y]==0&&a[i+x][j+y]=='W') {
				dnf(i+x,j+y);
			}
		}
	}
}
 ```
15. **注意在编码时灵活使用全局变量，不要一味的使用局部变量**
---
#### 2016年机试题目重点整理
1. 因子问题：注意**1没有因子**
2. StringBuffer可以用来存储多个字符、字符串、数字等，并且可以方便的获取并转为字符串进行输出。trim方法可以用来对字符串进行去空格操作
3. 熟练使用高级for循环处理数组的遍历。
4. 算术计算时注意表示形式，最常用的数字形式是int float double。在计算平均值的时候使用float或者double。
5. double型指定输出位数
```java
// 方法一：使用DecimalFormat
double d = 0.200;
DecimalFormat df = new DecimalFormat("0.00");
System.out.println(df.format(d));

// 方法二：使用String的format方法，传入格式和要转换的double类型变量。
double d = 0.6544;
String s=String.format("%.2f",d);
System.out.println(s);
```
6. 字符串变小写toLowerCase；变大写toUpperCase
7. 考试时拿到题目首先拿笔在纸上写写流程，在动手写代码，找到最优解之后再写代码。
8. 一分钟等于60秒，1秒等于1000毫秒
```java
// 求分、秒、毫秒的平均值
private static void getTimeAverage(int minute, int second, int millisecond) {
	// 首先先将对应的毫秒、秒、分钟相加的和转变为正确格式
	int newsecond = millisecond/1000;
	millisecond = millisecond%1000;
	second = second+newsecond;
	int newminute = second/60;
	second = second%60;
	minute = (minute+newminute)%60;
		
		
	// 接下来将对应的分钟、秒、毫秒进行除3求平均操作
	int aveminute = minute/3;
	second = (minute%3)*60+second;
	int avesecond = second/3;
	millisecond = (second%3)*1000+millisecond;
	int avemillisecond = millisecond/3;
		
	// 输出结果
	System.out.println(aveminute+" "+avesecond+" "+avemillisecond);
}
```
---
#### 2017年机试题目重点整理
1. 快速排序
```java
/**
 * 快速排序函数实现
 * @param R
 * @param l
 * @param r
 */
static void QuickSort(int R[],int l,int r) {
	int i,j,temp;
	// 快速排序开始条件
	if(l<r) {
		i = l;
		j = r;
		temp = R[l];
		// 一次快速排序
		while(i<j) {
			while(R[j]>temp&&i<j) {
				j--;
			}
			if(i<j) {
				R[i] = R[j];
				i++;
			}
			while(R[i]<temp&&i<j) {
				i++;
			}
			if(i<j) {
				R[j] = R[i];
				j--;
			}
		}
			
		// 一次排序结束确定temp的位置
		R[i] = temp;
		// 递归执行剩余的部分进行排序
		QuickSort(R,l,i-1);
		QuickSort(R,i+1,r);
	}
}
```
2. 冒泡排序记得排序的结束条件：一趟排序没有发生元素的交换。
3. 文件操作
```java
// 打开文件
Scanner scanner = new Scanner(new FileInputStream("data.txt"));
// 注意打开的文件在当前项目根文件夹下
// 注意文件的打开需要使用try-catch
```
4. 二叉树相关操作
```java
// 主要分为建立二叉树以及二叉树的应用，重点是建立二叉树。

// 建立二叉树，一个二叉树是由多个节点和边组合而成的，二叉树是一个类，而节点也是一个类，具有左节点和右节点以及节点保存的数据，这些可以通过类来实现。

class BinaryTree{
	// 根节点
	private Node root;
	
	public BinaryTree() {
		setRoot(null);
	}
	/**
	 * 内部节点类
     * @author 姓名：王鑫    准考证号：
	 *
	 */
	private class Node{
		// 左节点
		private Node left;
		// 右节点
		private Node right;
		// 节点数据
		private int data;
		
		/**
		 * 构造函数，初始化节点
		 * @param data
		 */
		public Node(int data) {
			this.left = null;
			this.right = null;
			this.data = data;
		}
	}
	
	/**
	 * 迭代构建查找二叉查找树
	 * 建立二叉查找树是在根节点上建立一些其他的节点，新加入的节点首先得与根节点的值进行比较。
	 * @param node
	 * @param data
	 */
	public void buildTree(Node node,int data) {
		// 根节点为空则创建一个新的根节点
		if(null == getRoot()) {
			setRoot(new Node(data));
		}else {
			// 待插入节点值比当前节点值小，往左边插，否则往右边插
			if(data < node.data) {
				// 左节点为空则插到左节点上，否则迭代进行插入
				if(null == node.left) {
					node.left = new Node(data);
				}else {
					buildTree(node.left,data);
				}
			}else {
				// 右节点为空则插到右节点上，否则迭代进行插入
				if(null == node.right) {
					node.right = new Node(data);
				}else {
					buildTree(node.right,data);
				}
			}
		}
	}
	
	/**
	 * 先序遍历：根---》左---》右
	 * @param node
	 */
	public void preOrder(Node node) {
		// 得在有树的情况下进行遍历树操作
		if(null != node) {
			System.out.println(node.data);
			preOrder(node.left);
			preOrder(node.right);
		}
	}
	
	/**
	 * 中序遍历：左---》根---》右
	 * @param node
	 */
	public void inOrder(Node node) {
		if(null != node) {
			preOrder(node.left);
			System.out.println(node.data);
			preOrder(node.right);
		}
	}
	
	
	/**
	 * 后序遍历：左---》右---》根
	 * @param node
	 */
	public void postOrder(Node node) {
		if(null != node) {
			preOrder(node.left);
			preOrder(node.right);
			System.out.println(node.data);
		}
	}
	/**
	 * 层次遍历
	 * @param node
	 */
	public void levelOrder(Node node) {
		// 创建队列用来保存层次节点
		LinkedList<Node> queue = new LinkedList<Node>();
		// 假如当前节点不为空则入队
		if(null != node) {
			queue.offer(node);
		}
		// 当队列不为空则打印当前队列元素，接下来判断其左节点，左节点不为空则左节点入队，右节点是同样的操作。
		while(!queue.isEmpty()) {
			Node n = queue.poll();
			System.out.println(n.data);
			if(null != n.left) {
				queue.offer(n.left);
			}
			if(null != n.right) {
				queue.offer(n.right);
			}
		}
	}

	public Node getRoot() {
		return root;
	}


	public void setRoot(Node root) {
		this.root = root;
	}
}

// 二叉树的应用
public class Question5 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		// 创建一个二叉树
		int a[] = {2,4,12,45,21,6,111};
		// 创建一个二叉树对象
		BinaryTree tree = new BinaryTree();
		for(int i:a) {
			tree.buildTree(tree.getRoot(), i);
		}
		
		// 前序遍历
		System.out.println("前序遍历");
		tree.preOrder(tree.getRoot());
		// 中序遍历
		System.out.println("中序遍历");
		tree.inOrder(tree.getRoot());
		// 后序遍历
		System.out.println("后序遍历");
		tree.postOrder(tree.getRoot());
	}
}
```
5. java中的栈为Stack（入栈：push；出栈：pop；获取栈顶元素：top）；队列为：LinkedList（进队列：offer；出队列：pull）；集合为ArrayList（添加元素：add；集合迭代：高级for循环）；
6. 注意String类型的变量比较其值时使用的是equals方法。
7. 质数：只能被1以及其自身整除的数
```java
private static void showZhishu(int[] a) {
	for(int i:a) {
		// 标识符，确定是否为质数
		int flag = 0;
		for(int j=2;j<i;j++) {
			// 假如能被2到i-1的数整除则不是质数，改变标识符
			if(i%j==0) {
				flag =1;
				break;
			}
		}
		// 只能被1以及自身整除，为质数打印,标识符未改变
		if(flag == 0) {
			System.out.println(i);
		}
	}	
}
```
8. 遇到编写一个系统类的题目一般是最后一道题，用剩余的时间来写就好，这类题一般很简单。

### 机试总结
总的来说，机试是比较简单的。主要是得耐心分析题目，找出最优解，然后在动手编写程序。你自己的水平应付这小考试是不在话下的。don't warry,it's ok.
尽量将所有的题目都做了，这才是你跟他们最大的不一样！！！

### 心理测试

暂时不需要准备

### 笔试（软件工程）

软件工程书上的知识点背诵，自己做过的题库也再看一遍。重点按照章节顺序整理在下面：

---
1. 软件工程三要素：方法、工具、过程
2. 软件定义（程序+数据+文档）：满足功能要求和性能的指令或计算机程序集合；处理信息的数据结构；描述程序功能以及程序如何操作和使用所要求的文档。
3. 软件危机：是在软件开发和维护过程中所遇到的一系列严重问题。
4. 软件危机目前所面临的主要问题：(1) 对软件开发成本和进度的估计常常很不准确。(2) 软件的质量常常靠不住。(3) 软件常常是不可维护的。(4) 软件通常没有适合的文档。(5) 用户对已完成的软件不满意的情况经常发生。
5. 产生软件危机的原因：(1) 与软件本身的特点有关。(2) 和软件开发和维护的方法不正确有关。
6. 软件工程：是指导计算机软件开发和维护的一门工程性学科，采用工程的原理、技术、概念和方法来开发和维护软件。
7. 软件工程方法学：(1) 传统方法学(2) 面向对象方法学
8. 软件生命周期：三时期：软件定义、软件开发、软件维护；八阶段：软件定义、可行性分析、需求分析、概要设计、详细设计、编码和单元测试、综合测试、软件维护。
9. 软件过程：为了获得高质量的软件所需要完成的一系列任务的框架
10. 瀑布模型：适用于功能性能需求明确完整，无重大变化的软件系统的开发。特点是：具有顺序性和依赖性，能够保证质量和完成时间。优点：可强迫开发人员采用规范的方法；严格规定了每个阶段必须提交的文档；要求每个阶段交出的所有产品都必须经过质量保证小组的仔细检验。缺点：瀑布模型几乎完全依赖与书面的规格说明，很可能导致最终开法出来的软件产品并不能真正满足用户的续求。
11. 原型模型：适用于预先不能确切定义需求的软件系统的开发。
12. 增量模型：把软件产品作为一系列的增量构件来设计集成和测试。优点：能在较短的时间内向用户提交可以完成部分工作的产品。
13. 螺旋模型：适用于续求不明确，特别是大型软件系统的开发。优点：有利于已有软件的重用；减少了过多的测试和测试不足所带来的风险；有助于确保软件质量。缺点：是风险驱动的。
14. rational统一过程（rup模型）：工作阶段：初试阶段、精化阶段、构建阶段、移交阶段。rup使用迭代和增强来开发软件。
15. 演化模型：适用与预先不能完整定义软件续求的开发。用户可以给出待开发系统的核心续求，并且当看到核心续求实现之后，能够有效的提供反馈，以支持系统的最终设计和实现。
---
1. 可行性研究的任务：(1) 首先需要进一步分析和澄清问题定义。(2) 导出系统的逻辑模型
2. 可行性分析包括：经济可行性、技术可行性、操作可行性。
3. 数据流图：是一种图形化技术，用来描述信息流和数据从输入移动到输出中所经受的变化。包括：数据源、数据处理、数据存储、数据流。
4. 数据字典：是关于数据信息的集合，也就是对数据流图中包含的所有元素的定义的集合。包括：数据流、数据元素、数据存储、数据处理。
---
1. 续求分析：开发人员准确的理解用户的续求，进行细致的调查分析，将用户非形式的续求陈述转化为完整的续求定义，再由续求定义转换到相应的续求规格说明的过程。任务：功能需求、性能需求、数据需求。
2. 设计人机界面，必须考虑哪几个方面：(1)系统的响应时间。(2)用户的求助机制。(3)错误信息的处理。(4)命令方式
3. 软件概要设计：把一个软件需求转换为软件表示时，首先谁出软件总的体系结构。基本任务：(1)设计软件系统结构。(2)进行数据结构数据库的设计。(3)编写概要设计的文档。(4)评审
---
1. 软件测试的目标：(1)测试是为了发现程序中的错误而执行程序的过程。(2)好的测试方案是发现迄今为止尚未发现的错误的测试方案。(3)成功的测试是发现了至今为止尚未发现的错误的测试。
2. 测试用例：为了进行有效的测试而设计的输入数据和预期的输出数据。
3. 单元测试重点：模块接口、局部数据结构、重要的执行通路、出错处理通路、边界条件。
4. 集成测试方法：自底向上、自顶向下
5. 白盒测试：逻辑覆盖（语句覆盖、判定覆盖、条件覆盖、条件组合覆盖）、控制结构测试
6. 黑盒测试：主要测试系统的功能，测试方法：边界值分析、等价类划分、错误推测。
---
1. UML九种试图：类图、用例图、活动图、顺序图、流程图、模块图、状态图、部署图、构建图
2. 软件设计的基本原理：模块化、抽象、信息隐藏、弱耦合、强内聚、可重用。
3. 面向对象特点：封装、继承、多态。
### 外语水平测试

短文翻译（自己最近几天每天翻译一段英文）

### 面试
面试首先需要使用英文进行自我介绍
   
Good morning/afternoon, my dear professors. I am very glad to be here for your interview.

My name is Wangxin. I graduated from Xi'an University of Architecture and Technology, majored in software engineering. I love my major so much, and I want to continue to study.  So I try my best for obtaining a key to Northwestern Polytechnical University.

Generally speaking, I am a hardworking student. No matter how difficult it is , I could concentrate on my study and succeeded in the end. My grade is in the first ten of the major, and I won the scholarship for two years. I like to learn new technology and have my own personal blog. When I in school, I organized  Android learning group. In addition to studying together, we can also made friends with common interests. I'm a stable person, in other words, everyone believes in me. Well, in my spare time, I like running and I insist on running every day. 

Ok, that's all, thank you for your attention.

接下来面试中还会问到一些其他的问题，接下来分类进行整理：

### 英文提问

老师会用英文提问一些问题,常用的题目如下:

1. why did you choose our university?
> i do love the atmosphere in your university. It's full of technical spirits.
in here I can learn more professional knowledge.
2. do you have any hobbies?
> in my spare time,i like runing,biking and i instit on excuting every day.i also like watch english movie and listen english song.Because I like the philosophy of life that foreign movies tell.
3. who is your idol?
> Elon Musk(伊隆·马斯克),he is the boss of Tesla paypal spaceX and so on.he is my idol,because he can do things that others can't do,At the same time, he will realize the dream of others.What I admire most is: in the face of setbacks, never give up.as he side:"if you're going through the hell, keep going."
4. 没听清老师问题时，可以请老师再重复一遍。
> sorry,i can't follow you.
>
> could you please repeat that question again? i'd like to listen to it carefully.
5. 遇到不会的问题时直接告诉老师不知道
> sorry,but i have no idea about it.
6. 相关专业课英文名称
> * 数据结构：data structures
> * 离散数学：Discrete Mathematics
> * 操作系统：Operating System
> * 计算机网络：computer network
> * 数据库原理：database Principles
> * 编译原理：compiling principles
> * 软件工程：software engineering
7. do you hava any questions to ask?
> i don't hava any question.thank you.
8. 常用回答：
> thank you for your advice.
> 
> i will see to it.
9. 软件工程定义：
> Software Engineering is the application of engineering to the development of software in a systematic method.

### 专业提问
**注意：**
面试中老师可能会问一些比较难的题目，此时不要慌张，如实回答老师的问题，老师也可能是在看你的水平怎么样。注意不会的不要瞎说，切记顶撞老师，老师说的都是对的。
* **毕设内容**

毕设的题目是：**《基于课程网站数据库优化设计与实现》**
主要是以课程网站建设为背景，采用MongoDB作为该网站的数据库来存储学生和教师的数据。

课程网站项目开发使用MEAN开发框架，这是一种新型的网站全栈开发框架，是MongoDB+Express+AngularJS+NodeJS四个框架的第一个字母组合。

我的主要任务是使用MongoDB存储课程网站所需的数据，并优化数据库的存储，保证数据库所存数据的安全。

MondoDB是一种非关系型数据库，是专门为可扩展性、高性能和高可用性所设计的数据库，是一种内存型数据库。经过我的测试，MongoDB非关系型数据库在性能上对于传统的关系型数据库具有明显的优势。但是由于MongoDB是内存型数据库，当服务器的内存内占满之后，MongoDB数据库的性能会下降到和普通的硬盘型数据库一致。

MongoDB数据库集合设计跟普通的数据库设计相比来说更加自由，支持完全分离、完全内嵌和部分内嵌的设计方式。

完全分离：按照传统数据库的范式化设计，一个实体对应一张表。查询慢，修改快

完全内嵌：反范式化设计，将所需要的数据以集合的方式存储在一个集合中。查询快，修改慢

部分内嵌：结合完全分离和完全内嵌的设计方式，将所需要一次查找的进行内嵌，将需要修改的分开进行存储。

MongoDB数据库的优化主要是在查询操作比较密集的字段上创建对应的索引，其特色是支持单字段索引、多键索引（数组）、全文索引和地理位置索引。数据库的优化是毕设中的一个重点。
还编写了对应的Nodejs连接MongoDB所需的数据库连接池，是毕设中的一个难点。

我所写的连接池支持连接数动态变化，为连接池设置一个最小连接数和最大连接数，以及一个默认连接数，启动连接池时初始化默认个连接放在连接池中，当连接数超过当前默认连接数且不超过最大连接数时就再创建当前连接数的一半加入到连接池中，这样一直增加到连接池达到最大连接数为止。当当前使用的连接数少于连接池中总的连接数且其一半小于最小的连接数，则将当前连接池中的连接数减少一半。这样便实现连接池的动态变化。

* **所做项目**
本科期间所做的项目主要有《移动教学助手APP》、《爱派之家分销网站》、《哈夫曼编译码系统》

《移动教学助手APP》：针对建大学生和老师日常教学活动所编写的Android应用。学生能够对教学资源、教学活动及通知进行查看，能够下载教学资源、参加教学活动。教师能够上传教学资源（包括上传本地文件、添加图文页面等）、创建教学活动（包括创建投票、讨论。系统能够提供对课堂考勤及考勤信息的管理，还能实现对平时成绩（包括考勤、作业、实验等）的管理及统计。

系统后台使用Bmob云平台提供数据存储支持，使用高德的定位技术实现课题签到。系统采用教师端以及学生端两个平台。

系统的主要特色是课堂点名功能，包括：随机生成点名码、实时位置信息定位、考勤结果及时查看等特色


《爱派之家分销网站》：爱派之家分销网站是一个面向广大分销商进行分销体系管理的在线网站。网站采用MVC三层架构进行开发，是基于JSP、Servlet以及JDBC集成开发的一个Java Web网站。项目采用Mysql存储数据，采用了预排序遍历树算法。

系统的主要功能是分销管理，在分销管理中，各级分销代理商可以以图形的方式生动形象的看到自己所在的分销系统中的位置。

分销管理主要用到了预排序遍历树算法也称非递归无限极算法，这是一种数据库存储数据结构的算法。

预排序遍历树算法是使用嵌套集模型来存储数据，在数据结构中添加lft和rgt两个属性作为标识符，相当于对树进行先序遍历进行排序,再添加父节点id和父节点深度标识符表示当前元素所处的层级。查询一个元素的所有子元素只需要查询大于父元素左值，小于父元素右值的条件。

预排序遍历树算法的核心就是牺牲了写的性能来换取读取的性能

《哈夫曼编译码系统》：通过建立哈夫曼树来实现哈夫曼编码和解码的实现。c++语言编写，MFC实现界面。
哈夫曼树是一颗带权路径最短的二叉树，其生成的编码是最短前缀码。

* **数据结构知识点**

1. 数据结构分为逻辑结构和物理结构，逻辑结构分为线性结构和非线性结构，非线性结构包括：图、树、网状结构；物理结构包括连续存储和非连续存储。

2. 线性表实现包括顺序表和链表。还有双链表，单循环链表，双循环链表等概念。
3. 栈和队列的特性：栈：先进后出；队列：先进先出
4. 树，二叉树，森林的基本概念。特殊二叉树：查找树，哈夫曼树，AVL平衡树。
5. 图，有向完全图：具有n（n-1）条边的的有向图。无向完全图：具有n（n-1）/2条边的无向图。
6. 图的存储结构：邻接表和邻接矩阵。邻接矩阵：使用二维数组来保存图；邻接表是一种链式存储结构，分为数据和指向下一个连表的指针。
7. 图的深度优先搜索遍历和广度优先搜索遍历。深度优先搜索遍历：任取一个顶点，访问之，标记以访问，然后检查这个顶点的所有邻接顶点，递归访问其中未被访问过的顶点。广度优先遍历算法：使用队列，类似与树的层次遍历。
8. 最小生成树算法（针对无向图）：普里姆算法：加点；克鲁斯卡尔算法：加边（适用于手工构造）
9. 最短路径算法：迪杰斯特拉算法：求某一顶点到其余各顶点的最短路径，建立dist和path两个数组来分别存储从起点到各点的最短路径长度和到达这些点的路径；弗洛伊德算法：求图中任意顶点到其余各点的最短路径。
10. 拓扑排序：按照活动的先后顺序进行排序.关键路径:AOE网中的最大路径长度,是图中的最长路径也是整个工期所完成的最短时间.
11. 排序:

![排序](/assets/images/2018-03/20130801171021937.jpg)

12. 查找:折半查找,b+树,b-树(多路查找的平衡m叉查找树,b+树的叶子节点为索引作用,b-树每个关键字对应一个记录的存储地址),散列表(Hash表):冲突解决方法:开放定址法(线性探测法,平方探测法),链地址法.

* **数据库知识点**
1. **ACID**：是数据库事务正确执行的四个基本要素的缩写，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务的数据库，必需要具有这四种特性，否则在事务过程当中无法保证数据的正确性。**事务**：是数据库的一组操作序列，这些操作要么全做要么全不做，是一个不可分割的整体。
2. **数据模型**：概念模型（物理模型，数学模型，结构模型，仿真模型）、层次模型、网状模型、关系模型、面向对象模型。
3. 数据库三级模式：**模式**（数据库中全体数据的逻辑结构和特性的描述，是所有用户的公共数据试图，一个数据库只有一个模式）、**内模式**（是数据再数据库内部实际存储的表示方式，一个数据库只有一个内模式）、**外模式**（是与某一应用有关的系统的逻辑表示，一个数据库可以有多个外模式，但一个应用程序只能使用一个外模式）。
4. 内模式与模式物理独立；外模式与模式逻辑独立。三级模式两级映像优点：保证数据的安全和独立，有利于数据共享。可以单独修改模式映像，保证数据独立性。
5. **候选码**：关系中的某一属性组能唯一的标识一个元组，该属性组为候选码。**主码**：多个候选码中的一个为主码。**外部码**：一个关系的一个属性与另一个关系的主码对应，则该码成为外部码。
6. 关系的三种完整性约束：实体完整性、参照完整性、用户定义的完整性。
7. **等值连接**：从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。**自然连接**：是一种特殊的等值连接，两个关系中进行比较的分量必须时相同的属性组，在结果中把重复的属性列去掉。也就是说：自然连接是去掉重复列的等值连接。**外连接**：把舍弃的元组也保存在结果关系中，而在其他的属性列上填空值。**左外连接**：只把左边关系R中要舍弃的元组保留。**右外连接**：只把右边关系S中要舍弃的元组保留。
8. SQL（关系数据库标准语言）语句：
```sql
#数据定义（模式、表、视图、索引）
CREATE SCHEMA DROP SCHEMA
CREATE TABLE DROP TABLE
CREATE VIEW DROP VIEW
CREATE INDEX DROP INDEX
#sql修改视图和索引时需要先将其删除之后再进行重建

#定义模式
CREATE SCHEMA 模式名 AUTHORIZATION 用户名
#删除模式
DROP SCHEMA 模式名 <CASCADE|RESTRICT>
CASCADE（级联）：删除模式的同时把该模式中所有的数据库对象全部删除。
RESTRICT（限制）：没有任何下属的对象的时候才能执行。

#定义表
CREATE TABLE 表名 列名 数据类型 列级完整性约束条件

#修改表
ALTER TABLE 表名 [ADD 新列名 数据类型 完整性约束条件][DROP 列名 完整性约束名][ALTER COLUMN 列名 数据类型]

#删除表
DROP TABLE 表名 <CASCADE|RESTRICT>
CASCADE：在删除表的同时，将相关的依赖对象一起删除。
RESTRICT：如果存在依赖该表的对象（索引、视图、触发器），则该表不能被删除。

#索引
#建立索引的目的：加快查询速度

#创建索引
CREATE [UNIQUE][CLUSTER] INDEX 索引名 ON 表名 (列名 [次序])
#用次序来指定索引值的排列次序，升序：ACS（默认）降序：DESC
UNIQUE表明此索引的每一个索引值只对应唯一的数据结构，对已含重复值的列不能建立唯一索引。
CLUSTER表明建立的所以是聚簇索引，按照物理顺序来建立索引顺序。一个基本表上最多只能建立一个聚簇索引，在经常更新的列上不宜建立聚簇索引。

#删除索引
DROP INDEX 索引名

#数据查询
SELECT 属性名 FROM 表名 WHERE 查询条件
#完整版语句格式
SELECT [ALL|DISTINCT] 属性名 INTO 表名 FROM 表名、视图名 WHERE 查询条件 GROUP BY 列名 HAVING 表达式 ORDER BY 列名 ASC|DESC

#单表查询：选择表中的若干列
#指定DISTRICT关键字，去掉表中重复的行，其作用范围是所有目标列。SELECT子句默认情况下是保留重复元组（ALL）

#模糊查询LIKE
%：代表任意长度的字符串
_：代表单个字符串

#WHERE查询条件中IS是用来判断而=是用来等值。

#ORDER BY是用来对查询结果进行排序
#聚集函数：对查询结果集中的某列进行计算或统计
#GROUP BY对查询结果进行分组，与HAVING结合使用

#HAVING和WHERE子句的区别：作用对象不同
WHERE子句作用于基表或者视图，从中选择满足条件的元组
HAVING短语作用于组，从中选择满足条件的组。

#数据更新

#插入数据
INSERT INTO 表名[属性列。。。] VALUES(常量1.。。)

#修改数据
UPDATE 表名 SET 列名=表达式 。。。 WHERE 条件

#删除数据
DELETE FROM 表名 WHERE 条件

#视图：从一个或多个基本表中导出的表
#特点：虚表，只存放视图的定义，不存放视图对应的数据。基表中的数据发生变化，从视图中查询出的数据也会随之改变。

#定义视图
CREATE VIEW 视图名 [列名] AS 子查询 [WITH CHECK OPTION]
[WITH CHECK OPTION]保证更新、插入、删除时仍满足视图定义

#删除视图
DROP VIEW 视图名
```
9. 什么是基本表，什么是视图，两者的区别和联系是什么？为何要引入视图？
> **基本表**：是独立存放的表，在sql中，一个关系对应一个基本表
> 
>**视图**:是从一个或多个基本表中所导出的表，视图本身并不独立存储在数据库中，是一个虚表，数据库中只存储视图的定义，而数据仍存储在导出视图的基本表中。
>
> 视图和基本表在概念上等同，用户可以像使用基本表那样使用视图，也可以在视图上再定义视图。
>
>为何要引进视图（视图的作用）：
>
>1. 视图能够简化用户的操作，聚焦与所关心的数据上
>2. 视图使用户能以多种角度看到同一数据，增加灵活性
>3. 视图对重构数据库提供了一定程度上的逻辑独立性
>4. 视图能够对机密数据提供安全防护
>5. 适当的利用视图可以更清晰的表达查询
10. 数据库安全防护措施：用户身份标识、存取控制、视图机制、审计、数据加密
11. 授权和回收语句
```sql
#授权
GRANT 权限 ON 对象类型 对象名 TO 用户 [	WITH GRANT OPTION]
对象类型是TABLE VIEW等
对象名就是对应的表名和视图名

#收回
REVOKE 权限 ON 对象类型 对象名 FROM 用户

#创建用户时授权
CREATE USER 用户名 WITH [DBA|RESOURCE|CONNECT]
DBA：超级用户
RESOURCE：可以创建表
CONNECT：默认权限，只能登陆数据库
```
12. **数据库完整性**：是防止数据库中存在不符合语义的数据。**数据库安全性**：保护数据库，防止被恶意破坏和非法存储。
13. **触发器**：是用户定义在表上的一类由事件驱动的特殊过程。只能再一个表上建立触发器。
```sql
#创建触发器
CREATE TRIGGER 触发器名 {BEFORE|AFTER} 触发事件 ON 表名 FOR EACH {ROW|STATMENT} WHEN 触发条件

#删除触发器
DROP TRIGGER 触发器名 ON 表名
```
14. **存储过程**：是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中。
15. 123NF范式：是为了消除插入、更新、删除异常
> 1NF：列不可分。每一列都是不可分割的基本数据项。
>
> 2NF：在第一范式基础上，对于多关键字表，非主属性不能部分依赖于主键,对于单关键字表，不存在部分依赖情况，总之就是不存在部分依赖情况。
> 
> 3NF：在第二范式基础上，非主键列必须直接依赖于主键，非主键列之间不能存在依赖关系。
>
> BCNF：在第三范式的基础上，数据库表中不存在关键字段决定关键字段的情况。
16. 数据库设计基本步骤：
> 1. 需求分析
> 2. 概念结构设计
> 3. 逻辑结构设计
> 4. 物理结构设计
> 5. 数据库实施
> 6. 数据库运行和维护
17. 并发操作可能会产生哪几类数据不一致：
> 1. 丢失修改
> 2. 不可重复读
> 3. 读脏数据

* **网络知识点**
1. 交换方式：电路交换、报文交换、分组交换
2. 网络按范围可以分为：广域网、城域网、局域网、个人区域网
3. 网络协议三要素：语法、语义、同步
4. **OSI体系结构**：物理层（在物理链路上透明的传输比特流）、数据链路层（成帧、差错控制、流量控制、传输管理）、网络层（对分组进行路由选择、并实现流量控制、拥塞控制）、传输层（负责主机中两个进程之间的通信）、会话层（会话层允许不同主机上两个进程之间进行通信）、表示层（用于处理两个系统之间交换信息的表示方式）、应用层（为特定的网络应用提供访问系统的方式）。**TCPIP体系结构**：网络接口层、网际层、传输层、应用层。
---
1. 物理层传输媒体：双绞线、同轴电缆、光纤
2. 信道复用技术：频分复用、时分复用、统计时分复用、波分复用、码分复用
3. 物理层硬件设备：集线器、中继器（多端口集线器）
4. 数据链路层设备：交换机（多端口网桥）、网桥
5. 网络层设备：路由器
---
1. 数据链路层提供的服务：无确认无连接服务、有确认无连接服务、有连接有确认服务。
2. CSMA（载波侦听多路访问）协议：1坚持CSMA，非坚持CSMA，p坚持CSMA，
3. CSMA/CD（载波侦听多路访问/碰撞检测）：先听后发、边听边发、冲突停发、随机重发。
4. CSMA/CA（载波侦听多路访问/碰撞避免）：在无线局域网中只能使用CSMA/CA原因：接收信号的强度往往会小于发送信号的强度，容易受到环境等的影响。并不是所有的站点都能听到对方。
---

* **操作系统知识点**
1. 进程：是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。
2. 线程：是进程内的一个执行单元，是进程内的一个可调度实体。
3. 进程间通信方式：**共享存储器系统**（在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写实现通信）、**消息传递系统**（直接利用通信命令来进行通信）、**管道通信系统**（用于连接读进程和写进程以实现他们之间进行通信的一个共享文件）
4. 死锁：进程组中的每一个进程都在无限期的等待其他进程占用的自己永远无法得到的资源的现象。
* **c c++ java语言知识点**
看一些网上别人整理的面试题目就好
* **机器学习知识点**
明天看自己写的笔记的前几页，唬住老师就好了。