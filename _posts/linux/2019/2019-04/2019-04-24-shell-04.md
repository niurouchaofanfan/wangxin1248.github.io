---
layout: post
title:  "shell 编程（四）：正则表达式"
date:  2019-04-24
desc: "正则表达式在 shell 脚本中经常被使用，并且也是开发过程中对字符串进行处理的高效工具"
keywords: "shell,脚本,运维,正则表达式"
categories: [Linux]
tags: [Linux,shell正则表达式]
---
# 正则表达式

在 shell 脚本中要查找一个文本文件中的内容的时候一般会使用 grep 命令。但是假如所要查找的字符串具有一定的模式，并且该模式包含以下的信息：

- 字符类：表示在模式中的一个字符
- 数量限定符： 某一个字符在字符串中出现的次数
- 位置关系：表示上面的某些数量的字符出现的位置

使用一些特殊语法表示字符类、数量限定符和位置关系，然后用这些特殊语法和普通字符一起表示一个模式，这就是**正则表达式（Regular Expression）**。

## 正则表达式分类

正则表达式按照是否可扩展来说分为两种规范：Basic 规范以及 Extended 规范。两种规范在 shell 脚本中正好对应 grep 以及 egrep 两种查找文件中字符串的命令。

其实两种规范的语法格式大致相同，只不过对于 Basic 规范来说，遇到 **?+{}|()** 这些符号时会被认为是普通字符，因此想要表示上述符号的特殊含义时需要加上 **\\** 转义字符即可。

如果用 grep 而不是 egrep ，并且不加-E参数，则应该遵照 Basic 规范来写正则表达式。

以下所介绍的语法格式是基于 Extended 规范的。

## 基本语法

### 字符类


| 字符 | 含义 | 举例 |
| ------ | ------ | ------|
| . | 匹配任意一个字符 | abc.可以匹配abcd、abc9等 |
| [] | 匹配括号中的任意一个字符 | [ abc ]d可以匹配ad、bd或cd |
| -  | 在[]括号内表示字符范围  |  [ 0-9a-fA-F ]可以匹配一位十六进制数字 |
| ^  | 位于[]括号内的开头，匹配除括号中的字符之外的任意一个字符  |[ ^xy ] 匹配除xy之外的任一字符，因此 [ ^xy ] 1可以匹配a1、b1但不匹配x1、y1|
| \[\[:xxx:]] | grep工具预定义的一些命名字符类 | \[\[:alpha:]]匹配一个字母，\[\[:digit:]]匹配一个数字 |

### 数量限定符

| 字符 | 含义 | 举例 |
| ------ | ------ | ------ |
| ? | 紧跟在它前面的单元应匹配零次或一次 | [ 0-9 ]? \ . [ 0-9 ]匹配0.0、2.3、.5等，由于.在正则表达式中是一个特殊字符，所以需要用\转义一下，取字面值 |
| + | 紧跟在它前面的单元应匹配一次或多次 | [a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+\ . [a-zA-Z0-9_.-]+匹配email地址 |
| * | 紧跟在它前面的单元应匹配零次或多次 | [0-9][0-9]*匹配至少一位数字，等价于[0-9]+，[a-zA-Z_]+[a-zA-Z_0-9] * 匹配C语言的标识符 |
| {N} | 紧跟在它前面的单元应精确匹配N次 | [1-9][0-9]{2}匹配从100到999的整数 |
| {N,} | 紧跟在它前面的单元应匹配至少N次 | [1-9][0-9]{2,}匹配三位以上（含三位）的整数 |
| {,M} | 紧跟在它前面的单元应匹配最多M次 | [0-9]{,1}相当于[0-9]?|
| {N,M} | 紧跟在它前面的单元应匹配至少N次，最多M次 | [0-9]{1,3}\ .[0-9]{1,3}\ .[0-9]{1,3}\ .[0-9]{1,3}匹配IP地址 |

注意 grep 找的是包含某一模式的行，而不是完全匹配某一模式的行。再举个例子，如果文本文件的内容是

```
aaabc
aad
efg
```

查找 a* 这个模式的结果是三行都被找出来了

```
$ egrep 'a*' testfile

aabc
aad
efg
```

a* 匹配0个或多个a，而第三行包含0个a，所以也包含了这一模式。单独用 a* 这样的正则表达式做查找没什么意义，一般是把 a* 作为正则表达式的一部分来用。

### 位置限定符

| 字符 | 含义 | 举例 |
| ------ | ------ | ------ |
| ^ | 匹配行首的位置 | ^Content 匹配位于一行开头的 Content |
| $ | 匹配行末的位置 | \;\$ 匹配位于一行结尾的 ; 号，^$匹配空行 |
| \< | 匹配单词开头的位置 | \< th 匹配... this，但不匹配ethernet、tenth |
| \\> | 匹配单词结尾的位置 | p\\>匹配leap ...，但不匹配parent、sleepy |
|\b | 匹配单词开头或结尾的位置 | \bat\b匹配... at ...，但不匹配cat、atexit、batch |
| \B | 匹配非单词开头和结尾的位置 | \Bat\B匹配battery，但不匹配... attend、hat ... |

位置限定符可以帮助 grep 更准确地查找，例如可以用 [0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} 来查找 IP 地址，找到这两行

```
192.168.1.1
1234.234.04.5678
```

如果用 \^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$ 查找，就可以把 1234.234.04.5678 这一行过滤掉了。

### 其它特殊字符

| 字符 | 含义 | 举例 |
| ------ | ------ | ------ |
| \ | 转义字符，普通字符转义为特殊字符,特殊字符转义为普通字符 | 普通字符<写成\<表示单词开头的位置，特殊字符.写成\.以及\写成\\就当作普通字符来匹配 |
|() | 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 | ([0-9]{1,3}\ .){3}[0-9]{1,3}匹配IP地址 |
| \| | 连接两个子表达式，表示或的关系 | n(o\|either)匹配 no 或 neither |