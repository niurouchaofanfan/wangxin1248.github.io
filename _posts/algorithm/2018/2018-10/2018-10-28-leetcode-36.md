---
layout: post
title:  "LeetCode 36.有效的数独"
date:  2018-10-28
desc: "LeetCode 题目之 36.有效的数独"
keywords: "LeetCode,刷题,算法,Python,LeetCode,有效的数独"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# 36.有效的数独

## 题目描述

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

![leetcode-image](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)
图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 '.' 表示。

示例 1:

输入:<br/>
[<br/>
  ["5","3",".",".","7",".",".",".","."],<br/>
  ["6",".",".","1","9","5",".",".","."],<br/>
  [".","9","8",".",".",".",".","6","."],<br/>
  ["8",".",".",".","6",".",".",".","3"],<br/>
  ["4",".",".","8",".","3",".",".","1"],<br/>
  ["7",".",".",".","2",".",".",".","6"],<br/>
  [".","6",".",".",".",".","2","8","."],<br/>
  [".",".",".","4","1","9",".",".","5"],<br/>
  [".",".",".",".","8",".",".","7","9"]<br/>
]<br/>
输出: true<br/>
示例 2:<br/>

输入:<br/>
[<br/>
  ["8","3",".",".","7",".",".",".","."],<br/>
  ["6",".",".","1","9","5",".",".","."],<br/>
  [".","9","8",".",".",".",".","6","."],<br/>
  ["8",".",".",".","6",".",".",".","3"],<br/>
  ["4",".",".","8",".","3",".",".","1"],<br/>
  ["7",".",".",".","2",".",".",".","6"],<br/>
  [".","6",".",".",".",".","2","8","."],<br/>
  [".",".",".","4","1","9",".",".","5"],<br/>
  [".",".",".",".","8",".",".","7","9"]<br/>
]<br/>
输出: false<br/>
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br/>
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br/>
说明:<br/>

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 1-9 和字符 '.' 。
- 给定数独永远是 9x9 形式的。

## 解题思路

根据题目所给的条件，对于一个有效的数独来说得满足以下的三个条件：

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

因此，我们就对一个 9*9 的矩阵分别判断 **行**、**列**、**3*3宫**

判断的标准是每行、每列、每个3*3宫 数字 1-9 不出现重复。在 python 中对是否有重复元素的处理最快的就是 **集合**。

可以将每行、每列、每个3*3宫中的数字分别存到列表中去，之后将列表转换为集合，判断集合和原列表的长度即可。

## 代码-Python

```python
class Solution:
    def isValidSudoku(self, board):
        """
        :type board: List[List[str]]
        :rtype: bool
        """
        # 判断行
        for i in range(0, 9):
            list1 = []
            for j in range(0, 9):
                # 是数字再做处理
                if board[i][j] != ".":
                    list1.insert(j, board[i][j])
            # 判断是否有重复数字
            if len(set(list1)) != len(list1):
                return False
        
        # 判断列
        for i in range(0, 9):
            list2 = []
            for j in range(0, 9):
                # 是数字再做处理
                if board[j][i] != ".":
                    list2.insert(i, board[j][i])
            # 判断是否有重复数字
            if len(set(list2)) != len(list2):
                return False
        
        # 判断3*3的矩阵
        for i in range(0, 9, 3):
            for j in range(0, 9, 3):
                list3 = []
                # 判断每一个3*3的小矩阵
                for m in range(i, i+3):
                    for n in range(j, j+3):
                        # 是数字再做处理
                        if board[m][n] != ".":
                            list3.insert(m+n, board[m][n])
                # 判断是否有重复数字
                if len(set(list3)) != len(list3):
                    return False
        return True
```