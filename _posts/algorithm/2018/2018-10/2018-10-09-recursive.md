---
layout: post
title:  "回溯问题总结"
date:  2018-10-09
desc: "算法设计题中经常会出现一些全排列的问题，这类问题一般是使用递归加回溯来完成"
keywords: "ACM,刷题,算法,C++,递归,回溯"
categories: [Algorithm]
tags: [ACM,算法,C++]
---
# 常见的回溯算法总结

## 全排列问题

### 问题描述

输入一个小于10的正整数n，按把每个元素都交换到最前面一次的方法，输出前n个小写字母的所有排列。

### 输入

输入一个小于10的正整数n。

### 输出

按把每个元素都交换到最前面一次的方法，输出前n个小写字母的所有排列。

### 输入样例

3

### 输出样例

abc<br/>
acb<br/>
bac<br/>
bca<br/>
cba<br/>
cab<br/>

### 分析

这种问题是简单的回溯问题，只需要使用递归来将所有的可能性遍历完之后输出即可。

遍历所有的可能性是通过递归搜索的方式。首先从第一个元素开始，将其依次与后面的元素交换位置，接着去搜索下一个位置的元素，按照这样的方式一直进行搜索，直到搜索到最后一个元素，此时便可以输出这种搜索的结果。最后还得将交换了位置的两个元素的位置交换回来。这样才能将所有的排列情况都表示出来。

### 代码

```c++
#include <iostream>
using namespace std;

int n;
char a[10] = {'a','b','c','d','e','f','g','h','i','j'};
void search(int m);
void visit();
void change(char& i,char& j);
int main() {
    int i;
    cin>>n;
    search(0);
	return 0;
}
void search(int m){
    int i;
    if(m==n){
        // 排列完成，打印输出结果 
        visit();
    }else{
        for(i=m;i<n;i++){
            change(a[m],a[i]);
            search(m+1);
            change(a[m],a[i]);
        }
    }
}

void change(char& i,char& j){
    char k;
    k = i;
    i = j; 
    j = k;
}
void visit(){
    int i;
    for(i=0;i<n;i++){
       cout<<a[i]; 
    }
    cout<<endl;
}
```

在实现了最基本的全排列问题之后，便可以去处理其他的一些基于全排列的算法问题，这类问题虽然看起来很复杂，但其实还是使用了全排列的思路来进行处理的。

## 穷举n位二进制数

### 描述

输入一个小于20的正整数n，要求按从小到大的顺序输出所有的n位二进制数，每个数占一行。

### 输入

输入一个小于20的正整数n。

### 输出

按从小到大的顺序输出所有的n位二进制数，每个数占一行。

### 输入样例

3

### 输出样例

000<br/>
001<br/>
010<br/>
011<br/>
100<br/>
101<br/>
110<br/>
111<br/>

### 思路

这种问题也是全排列的应用

对于二进制数来说只有0 1 两种取值，那么全排列的数就是n位的01之间的相互交换，可以先将第一个数先设置为0，在继续去递归的搜寻下一位，之后再将第一位数设置为1，再去递归的搜寻下一位。这样第一位为0和1的所有情况都已经被全部搜寻过了。对于第二位以及之后的每一位都是进行这样的相同的操作，直到搜寻到第n位，此时将搜寻的数据打印输出。

### 代码

```c++
#include <iostream>
using namespace std;

int n;
int a[20];

void search(int m);
void visit();
/*穷举n位二进制数*/
int main() {
    cin>>n;
	search(0);
	return 0;
}

/*递归寻找对应的所有可能*/
void search(int m){
    // 递归退出条件
    if(m==n){
        visit();
    }else{
        a[m]=0;
        search(m+1);
        a[m]=1;
        search(m+1);
    }
}

/*打印结果*/
void visit(){
    int i;
    for(i=0;i<n;i++){
        cout<<a[i];
    }
    cout<<endl;
}
```

掌握了回溯算法的关键步骤之后便可以来进行一些具体算法问题的求解，比如说 **0-1背包**问题。

0-1背包问题是贪心算法的最经典的题目。要求在一个给定大小的背包中装入价值最大的物品，这种问题便是通过回溯来进行处理的。

## 0-1背包问题

### 描述

需对容量为c 的背包进行装载。从n 个物品中选取装入背包的物品，每件物品i 的重量为wi ，价值为pi 。对于可行的背包装载，背包中物品的总重量不能超过背包的容量，最佳装载是指所装入的物品价值最高。

### 输入

多个测例，每个测例的输入占三行。第一行两个整数：n（n<=10）和c，第二行n个整数分别是w1到wn，第三行n个整数分别是p1到pn。
n 和 c 都等于零标志输入结束。
 
### 输出

每个测例的输出占一行，输出一个整数，即最佳装载的总价值。
 
### 输入样例

1 2<br/>
1<br/>
1<br/>
2 3<br/>
2 2<br/>
3 4<br/>
0 0<br/>

### 输出样例

1<br/>
4

### 思路

0-1背包问题是要求在给定容量的背包中装入最大的价值的物品。因此，这就要求将所有可能的物品都装入到背包中，然后计算所有可能装入的情况中价值最大的情况。

因此，就需要将所有物品是否装入的情况都表示出来，也就是简单的全排列问题。而且根据每一个物品装表示为1，不装表示为0。可以将n个物品的装入问题表示为n位二进制的全排列问题。

注意假如将所有物品的全排列情况都去判断每一个结果的最大价值的话所用的时间一定会超时，这时就需要加入对应的 **剪枝**操作。即将不满足的情况取消。

剪枝操作可以根据背包的重量是否还可以装入这个物品来判断，假如当前的物品装入后会超过背包的容量的话便不将该物品装入，直接判断下一个物品是否可以装。

### 代码

```c++
#include <iostream>

using namespace std;
int c,n,w[10],p[10];
int psum = 0,wsum = 0;
int maxvalue;
int search(int m);
int main()
{
    int i,j;
    cin >> n >>c;
    while(n!=0||c!=0)
    {
        //循环输入重量
        for(i = 0;i < n;i++)
        {
            cin >> w[i];
        }
        for(i = 0;i < n;i++)
        {
            cin >> p[i];
        }
            maxvalue = 0;
            wsum = 0;
            search(0);
            cout << maxvalue << endl;
            cin >> n >> c;

    }
    return 0;
}
int search(int m)
{
    int i;
    if(m == n)
    {
        // 回溯完所有的情况，将当前的价值与最大值进行更换
        if(psum > maxvalue)
        {
            maxvalue = psum;
        }
    }
    else{
        // 加上这个重量还满足条件 
        if(wsum + w[m] <= c)
        {
            // 先将这个物品装上
            wsum = wsum + w[m];
            psum = psum + p[m];
            // 回溯下一个物品
            search(m+1);
            // 再将这个物品放回去
            psum = psum - p[m];
            wsum = wsum - w[m];
        }
        // 当前物品不装也去进行递归下一个
        search(m+1);
    }
    return 0;
}
```