---
layout: post
title:  "LeetCode 136.只出现一次的数字"
date:  2018-10-19
desc: "LeetCode 题目之 136.只出现一次的数字"
keywords: "LeetCode,刷题,算法,Python,LeetCode,只出现一次的数字"
categories: [Algorithm]
tags: [LeetCode,算法,Python]
---
# 只出现一次的数字

## 问题描述

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]<br/>
输出: 1<br/>
示例 2:<br/>

输入: [4,1,2,1,2]<br/>
输出: 4<br/>

## 解题思路

做这道题首先需要一些简单的计算机基础，假如需要具有线性时间复杂度并且还不能使用额外的空间来实现这道题的话，就得找一些比较巧妙的算法。对于这道题来说，其实就是考 **位运算**

位运算是属于算法中用到次数较多的运算，一般来说比较具有技巧性。主要的位运算包含：与、或、异或

基本的位运算知识：

- 与运算（&）
  - 0 & 0 = 0
  - 1 & 1 = 1
  - 1 & 0 = 0
- 或运算（\|）
  - 0 \| 0 = 0
  - 1 \| 0 = 1
  - 1 \| 1 = 1
- 异或运算（^）
  - 1 ^ 1 = 0
  - 1 ^ 0 = 1
  - 0 ^ 0 = 0

根据上面的知识我们可以知道：**两个相同的数异或的结果为0，而0与任何一个数异或的结果为这个数**

根据这个知识点我们便可以来求解这道题。让一个 0 开始与数组中的第一个数异或，之后将异或结果继续与下一个数进行异或，这样直到数组中所有的数都被便利完，最后的结果变为那个没有重复的数。

## 代码-Python

```python
class Solution:
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        j = 0
        for i in nums:
            j ^= i
        return j
```