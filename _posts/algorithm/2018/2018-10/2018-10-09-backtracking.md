---
layout: post
title:  "回溯问题总结"
date:  2018-10-09
desc: "算法设计题中经常会出现一些全排列的问题，这类问题一般是使用递归加回溯来完成"
keywords: "ACM,刷题,算法,C++,递归,回溯"
categories: [Algorithm]
tags: [ACM,算法,C++]
---
# 常见的回溯算法总结

## 概念

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。

回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。

## 基本思想

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

## 用回溯法解题的一般步骤：

### 1.针对所给问题，确定问题的解空间：

首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

### 2.确定结点的扩展搜索规则

### 3.以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

---

接下来看一些经典的应用回溯法解决的问题

## （1）全排列问题

### 问题描述

输入一个小于10的正整数n，按把每个元素都交换到最前面一次的方法，输出前n个小写字母的所有排列。

### 输入

输入一个小于10的正整数n。

### 输出

按把每个元素都交换到最前面一次的方法，输出前n个小写字母的所有排列。

### 输入样例

3

### 输出样例

abc<br/>
acb<br/>
bac<br/>
bca<br/>
cba<br/>
cab<br/>

### 分析

这种问题是简单的回溯问题，只需要使用递归来将所有的可能性遍历完之后输出即可。

遍历所有的可能性是通过递归搜索的方式。首先从第一个元素开始，将其依次与后面的元素交换位置，接着去搜索下一个位置的元素，按照这样的方式一直进行搜索，直到搜索到最后一个元素，此时便可以输出这种搜索的结果。最后还得将交换了位置的两个元素的位置交换回来。这样才能将所有的排列情况都表示出来。

### 代码

```c++
#include <iostream>
using namespace std;

int n;
char a[10] = {'a','b','c','d','e','f','g','h','i','j'};
void search(int m);
void visit();
void change(char& i,char& j);
int main() {
    int i;
    cin>>n;
    search(0);
	return 0;
}
void search(int m){
    int i;
    if(m==n){
        // 排列完成，打印输出结果 
        visit();
    }else{
        for(i=m;i<n;i++){
            change(a[m],a[i]);
            search(m+1);
            change(a[m],a[i]);
        }
    }
}

void change(char& i,char& j){
    char k;
    k = i;
    i = j; 
    j = k;
}
void visit(){
    int i;
    for(i=0;i<n;i++){
       cout<<a[i]; 
    }
    cout<<endl;
}
```

在实现了最基本的全排列问题之后，便可以去处理其他的一些基于全排列的算法问题，这类问题虽然看起来很复杂，但其实还是使用了全排列的思路来进行处理的。

## （2）穷举n位二进制数

### 描述

输入一个小于20的正整数n，要求按从小到大的顺序输出所有的n位二进制数，每个数占一行。

### 输入

输入一个小于20的正整数n。

### 输出

按从小到大的顺序输出所有的n位二进制数，每个数占一行。

### 输入样例

3

### 输出样例

000<br/>
001<br/>
010<br/>
011<br/>
100<br/>
101<br/>
110<br/>
111<br/>

### 思路

这种问题也是全排列的应用

对于二进制数来说只有0 1 两种取值，那么全排列的数就是n位的01之间的相互交换，可以先将第一个数先设置为0，在继续去递归的搜寻下一位，之后再将第一位数设置为1，再去递归的搜寻下一位。这样第一位为0和1的所有情况都已经被全部搜寻过了。对于第二位以及之后的每一位都是进行这样的相同的操作，直到搜寻到第n位，此时将搜寻的数据打印输出。

### 代码

```c++
#include <iostream>
using namespace std;

int n;
int a[20];

void search(int m);
void visit();
/*穷举n位二进制数*/
int main() {
    cin>>n;
	search(0);
	return 0;
}

/*递归寻找对应的所有可能*/
void search(int m){
    // 递归退出条件
    if(m==n){
        visit();
    }else{
        a[m]=0;
        search(m+1);
        a[m]=1;
        search(m+1);
    }
}

/*打印结果*/
void visit(){
    int i;
    for(i=0;i<n;i++){
        cout<<a[i];
    }
    cout<<endl;
}
```

掌握了回溯算法的关键步骤之后便可以来进行一些具体算法问题的求解，比如说 **0-1背包**问题。

0-1背包问题是贪心算法的最经典的题目。要求在一个给定大小的背包中装入价值最大的物品，这种问题便是通过回溯来进行处理的。

## （3）0-1背包问题

### 描述

需对容量为c 的背包进行装载。从n 个物品中选取装入背包的物品，每件物品i 的重量为wi ，价值为pi 。对于可行的背包装载，背包中物品的总重量不能超过背包的容量，最佳装载是指所装入的物品价值最高。

### 输入

多个测例，每个测例的输入占三行。第一行两个整数：n（n<=10）和c，第二行n个整数分别是w1到wn，第三行n个整数分别是p1到pn。
n 和 c 都等于零标志输入结束。
 
### 输出

每个测例的输出占一行，输出一个整数，即最佳装载的总价值。
 
### 输入样例

1 2<br/>
1<br/>
1<br/>
2 3<br/>
2 2<br/>
3 4<br/>
0 0<br/>

### 输出样例

1<br/>
4

### 思路

0-1背包问题是要求在给定容量的背包中装入最大的价值的物品。因此，这就要求将所有可能的物品都装入到背包中，然后计算所有可能装入的情况中价值最大的情况。

因此，就需要将所有物品是否装入的情况都表示出来，也就是简单的全排列问题。而且根据每一个物品装表示为1，不装表示为0。可以将n个物品的装入问题表示为n位二进制的全排列问题。

注意假如将所有物品的全排列情况都去判断每一个结果的最大价值的话所用的时间一定会超时，这时就需要加入对应的 **剪枝**操作。即将不满足的情况取消。

剪枝操作可以根据背包的重量是否还可以装入这个物品来判断，假如当前的物品装入后会超过背包的容量的话便不将该物品装入，直接判断下一个物品是否可以装。

### 代码

```c++
#include <iostream>

using namespace std;
int c,n,w[10],p[10];
int psum = 0,wsum = 0;
int maxvalue;
int search(int m);
int main()
{
    int i,j;
    cin >> n >>c;
    while(n!=0||c!=0)
    {
        //循环输入重量
        for(i = 0;i < n;i++)
        {
            cin >> w[i];
        }
        for(i = 0;i < n;i++)
        {
            cin >> p[i];
        }
            maxvalue = 0;
            wsum = 0;
            search(0);
            cout << maxvalue << endl;
            cin >> n >> c;

    }
    return 0;
}
int search(int m)
{
    int i;
    if(m == n)
    {
        // 回溯完所有的情况，将当前的价值与最大值进行更换
        if(psum > maxvalue)
        {
            maxvalue = psum;
        }
    }
    else{
        // 加上这个重量还满足条件 
        if(wsum + w[m] <= c)
        {
            // 先将这个物品装上
            wsum = wsum + w[m];
            psum = psum + p[m];
            // 回溯下一个物品
            search(m+1);
            // 再将这个物品放回去
            psum = psum - p[m];
            wsum = wsum - w[m];
        }
        // 当前物品不装也去进行递归下一个
        search(m+1);
    }
    return 0;
}
```

接下来来看应用回溯求解的最经典的问题：8皇后问题

## （4）8皇后问题

### 描述

输出8皇后问题所有结果。

### 输入

没有输入。

### 输出

每个结果第一行是No n：的形式，n表示输出的是第几个结果；下面8行，每行8个字符，‘A’表示皇后，‘.’表示空格。不同的结果中，先输出第一个皇后位置靠前的结果；第一个皇后位置相同，先输出第二个皇后位置靠前的结果；依次类推。
 
### 输入样例
 
### 输出样例

输出的前几行：<br/>
No 1:<br/>
A.......<br/>
....A...<br/>
.......A<br/>
.....A..<br/>
..A.....<br/>
......A.<br/>
.A......<br/>
...A....<br/>
No 2:<br/>
A.......<br/>
.....A..<br/>
.......A<br/>
..A.....<br/>
......A.<br/>
...A....<br/>
.A......<br/>
....A...<br/>

### 思路

8皇后问题是最典型的回溯问题，为了得到所有可能的情况就必须将所有的情况都表示出来，然后在进行相应的判断，找出符合要求的情况。

注意，在回溯8皇后问题时，还是需要进行相应的剪枝操作，只有该位置可以放置皇后的情况下采取搜寻下一行的皇后位置。

为了更好的表示8黄后的位置，并不需要建立一个二维数组来存储8皇后的位置，只需要建立一个长度为8的一维数组，用角标来表示行数，角标对应的值表示改行的皇后的列的位置。

### 代码

```c++
#include <iostream>
#include <cstdlib>

using namespace std;
int a[8] = {0};
// 记录所有可能结果的次数
int sum = 0;

// 输出结果
void print()
{
    int i, j;
    cout << "No " << sum << ":" << endl;
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            if (a[i] == j)
                // 输出皇后
                cout << 'A';
            else
                cout << '.';
        }

        cout << endl;
    }
}

// 在该行该列是否可以放置皇后
int canplace(int row, int col)
{
    int i;
    for (i = 0; i < row; i++)

    {
        if (a[i] == col || abs(i - row) == abs(a[i] - col)) //之前的行没有同一列的，也没有在对角线上的
        return 0;
    }
    // 可以放置皇后
    return 1;
}

// 回溯搜索所有的结果
void search(int m)
{
    int i;
    // 搜寻完所有的8行结束
    if (m == 8)
    {
        sum++;
        print();
    }

    else
    {
        for (i = 0; i < 8; i++)
        {
            // 搜寻m行的皇后是否可以放置在i的位置上
            a[m] = i;
            if (canplace(m, i))
            {
                // 可以放置则搜寻下一行的皇后位置
                search(m + 1);
            }
        }
    }
}
int main()
{
    search(0);
    return 0;
}
```
