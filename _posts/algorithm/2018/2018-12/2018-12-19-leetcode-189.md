---
layout: post
title:  "LeetCode 198. 打家劫舍"
date:  2018-12-19
desc: "LeetCode 题目之 198. 打家劫舍"
keywords: "LeetCode,刷题算法,c++,LeetCode,198. 打家劫舍, 动态规划"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 打家劫舍

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]<br />
输出: 4<br />
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 

示例 2:

输入: [2,7,9,3,1]<br />
输出: 12<br />
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。

## 解题思路

这是一道动态规划的题目，一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。而动态规划的解决思路便是当前的最优解是由上一步的最优解得到的，也就是得找出其对应的 **递推公式**。

这道题的规则是劫匪不能同时抢劫相邻的屋子，即在累加时，只有两种选择：

1. 如果选择抢劫上一个屋子，则不能抢劫当前的屋子。这样，最大的收益便是抢劫上一个屋子的收益。
2. 如果选择抢劫当前的屋子，则不能抢劫上一个屋子。这样，最大的收益便是当前屋子的收益加上上一个屋子的上一个屋子的收益。

这样来看递归关系也就清晰了：**当前的最大收益=max（上一次收益，上上次收益+当前屋子的收益）**。那么，我们只要给这个递推公式一个初始值，那么只需循环下去便可以找到每一步的最优解。

初始情况下上一次的收益是 a=nums[0]，当前的最大收益是 b=max(nums[0],nums[1])。下一次的话 上一次的最大收益 a 变为 b，b 则使用递推公式了来求出当前的最大收益，接下来一直循环到结束。

## 代码-c++

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()<=1){
            return nums.size()==0?0:nums[0];
        }
        // 上一次的最大收益
        int a = nums[0];
        // 当前的最大收益
        int b = max(nums[0],nums[1]);
        // 开始循环
        for(int i=2;i<nums.size();i++){
            int temp = b;
            b = max(nums[i]+a, b);
            a = temp;
        }
        // b为最终的最优解
        return b;
    }
};
```