---
layout: post
title:  "LeetCode 206. 反转链表"
date:  2018-11-19
desc: "LeetCode 题目之 206. 反转链表"
keywords: "LeetCode,刷题算法,Python,LeetCode,反转链表"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 反转链表

## 题目描述

反转一个单链表。

示例:

输入: 1->2->3->4->5->NULL<br/>
输出: 5->4->3->2->1->NULL<br/>
进阶:<br/>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

## 解题思路

### 递归实现

首先实现这道题的思路如下图所示，根据这张图便可以实现出对应的代码：

![result](/assets/images/2018/2018-11/38.png)

### 迭代实现

这里简单的介绍下递归和迭代的基本概念：

**递归**:程序调用自身的编程技巧称为递归,是函数自己调用自己.

一个函数在其定义中直接或间接调用自身的一种方法,它通常把一个大型的复杂的问题转化为一个与原问题相似的规模较小的问题来解决,可以极大的减少代码量.递归的能力在于用有限的语句来定义对象的无限集合.

使用递归要注意的有两点:

1. 递归就是在过程或函数里面调用自身;

2. 在使用递归时,必须有一个明确的递归结束条件,称为递归出口.

 

递归分为两个阶段:

1. 递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;

2. 回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.

 

利用递归可以解决很多问题:如背包问题,汉诺塔问题,...等.

**迭代**:利用变量的原值推算出变量的一个新值，将输出做为输入,再次进行处理。如果递归是自己调用自己的话,迭代就是A不停的调用B.

递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换.能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.

迭代版的代码待做出来之后再来补充。



## 代码-cpp

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {

        // 创建一个新的节点
        ListNode* head1 = NULL;

        // 当原来的链表还没有被递归完便继续执行
        while(head != NULL){
            // 先将当前结点的后面的链表保存到a节点之后
            ListNode* a = head->next;
            // 将当前节点之后的节点变为 head1 所指向的节点
            head->next = head1;
            // 在将当前节点给head1指向
            head1 = head;
            // 最后更新 head 指针到下一个节点
            head = a;
        }

        // 返回新链表的头节点
        return head1;
    }
};
```