---
layout: post
title:  "LeetCode 190. 颠倒二进制位"
date:  2019-01-06
desc: "LeetCode 题目之 190. 颠倒二进制位"
keywords: "LeetCode,刷题算法,c++,190. 颠倒二进制位,其他"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 190. 颠倒二进制位

## 题目描述

颠倒给定的 32 位无符号整数的二进制位。

示例 1：

输入: 00000010100101000001111010011100<br />
输出: 00111001011110000010100101000000<br />
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br />
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：<br />


输入：11111111111111111111111111111101<br />
输出：10111111111111111111111111111111<br />
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。

提示：<br />

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

## 解体思路

这道题目还是属于 **位运算**的应用类题目。

为了实现一个32位的二进制数字的颠倒，首先要将原本的二进制的最后一位数变到一个新的32位数的第一位；而将原来数的倒数第二位变位新数的正数第二位；依次执行相同的操作32次即可。

![result](/assets/images/2019/2019-01/1.png)

那么便可以将上述过程表示成一个循环，而在循环中，取一个数的倒数第一位便是 **&1，右移一位**；将结果加到**0左移一位**的数上。循环32次即可。

![result](/assets/images/2019/2019-01/2.png)

## 代码-c++

```cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t m = 0;
        int i = 32;
        while(i--){
            m <<= 1;
            m += n&1;
            n >>=1;
        }
        return m;
    }
};
```