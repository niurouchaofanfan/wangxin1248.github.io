---
layout: post
title:  "LeetCode 191. 位1的个数"
date:  2019-01-04
desc: "LeetCode 题目之 191. 位1的个数"
keywords: "LeetCode,刷题算法,c++,191. 位1的个数,其他"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 191. 位1的个数

## 题目描述

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

示例 1：

输入：00000000000000000000000000001011<br />
输出：3<br />
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。<br />
示例 2：<br />

输入：00000000000000000000000010000000<br />
输出：1<br />
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。<br />
示例 3：<br />

输入：11111111111111111111111111111101<br />
输出：31<br />
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。<br />

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

## 解题思路

这道题按照思路来理解就是得将传入的十进制整数首先转换为二进制整数，之后再来判断所对应的二进制中为1的个数。

但是还有一个操作称为 **位运算**，可以直接在十进制整数上进行相应的二进制每一位进行运算。常见的位运算包括：

- & 与，两个位都为1时，结果才为1

- | 或，两个位都为0时，结果才为0

- ^ 异或，两个位相同为0，相异为1

- ~ 取反，0变1，1变0

- << 左移，各二进位全部左移若干位，高位丢弃，低位补0

- >> 右移，各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）

对于这道题目来说，我们可以直接对整数与1相与，这样会直接将整数转换为二进制来与二进制1进行与操作，1与1为1，与其他则为0。这样就将整数的最后一位是个为1统计到了，接下来只需将整数进行右移操作即将对应的二进制倒数第二位作为倒数第一位了，而且不用担心符号位的问题。这样循环下去直到整数对应的二进制变为0为止。

## 代码-c++

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n){
            result += n&1;
            n >>= 1;
        }
        return result;
    }
};
```