---
layout: post
title:  "LeetCode 300. 最长上升子序列"
date:  2019-07-16
desc: "LeetCode 题目之 300. 最长上升子序列"
keywords: "LeetCode,刷题算法,C++,300. 最长上升子序列"
categories: [Algorithm]
tags: [LeetCode,算法,C++]
---
# 最长上升子序列

## 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

说明:

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(n2) 。

进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

题目链接：[https://leetcode-cn.com/problems/longest-increasing-subsequence](https://leetcode-cn.com/problems/longest-increasing-subsequence)

## 解题思路-1

本题是一道**动态规划**的题目，可以按照求解动态规划问题的思路来求解：

- 什么问题？

该题目是要求出数组中最长的上升子序列的长度。（子序列不是连续的）

- 使用什么数据结构？

数组的长度不同所对应的的最长上升子序列的长度也是不同的，为了获取整个数组的最长上升子序列，那么就得首先知道之前的元素中的最长上升子序列的长度。因此得需要一个 dp数组来保存该数组所对应的从开始每一位元素为止目前的最长上升子序列的长度。用数组的角标来表示当前第几位元素所对应的最长上升子序列。

- 递推公式？

首先对于第0个元素来说，最长上升子序列只有他自己，所以 dp[0] = 1;

用 nums 来表示要被处理的数组，对于之后的每一个 nums[i]元素来说，需要找到该元素之前的元素 nums[j]（0<j<i）中比 nums[i] 小的中最大的那个元素，将其对应的 dp 数组中的值加一便是当前 dp[i] 的值。



## 代码

### C++实现

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        // 特殊情况处理
        if(n==0) return 0;
        vector<int> dp = vector(n,0);
        dp[0] = 1;
        int max_res = 1;
        // 开始填表
        for(int i = 1;i<n;i++){
            int max_tem = 0;
            for(int j=0;j<i;j++){
                // 得找到之前比自己小的才寻找其中最大的dp值
                if(nums[j]<nums[i]){
                    max_tem = max(max_tem, dp[j]);
                }
            }
            max_tem++;
            dp[i] = max_tem;
            max_res = max(max_res, max_tem);
        }
        // 返回结果
        return max_res;
    }
};
```